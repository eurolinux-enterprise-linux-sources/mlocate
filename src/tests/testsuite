#! /bin/sh
# Generated from ../tests/testsuite.at by GNU Autoconf 2.63.
#
# Copyright (C) 2006, 2008 Red Hat, Inc. All rights reserved.
# This copyrighted material is made available to anyone wishing to use, modify,
# copy, or redistribute it subject to the terms and conditions of the GNU
# General Public License v.2.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#
# Author: Miloslav Trmac <mitr@redhat.com>
#
# Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
# Free Software Foundation, Inc.
# This test suite is free software; the Free Software Foundation gives
# unlimited permission to copy, distribute and modify it.
## --------------------- ##
## M4sh Initialization.  ##
## --------------------- ##

# Be more Bourne compatible
DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in
  *posix*) set -o posix ;;
esac

fi




# PATH needs CR
# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits

as_nl='
'
export as_nl
# Printing a long string crashes Solaris 7 /usr/bin/printf.
as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
if (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='printf %s\n'
  as_echo_n='printf %s'
else
  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
    as_echo_n='/usr/ucb/echo -n'
  else
    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
    as_echo_n_body='eval
      arg=$1;
      case $arg in
      *"$as_nl"*)
	expr "X$arg" : "X\\(.*\\)$as_nl";
	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
      esac;
      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
    '
    export as_echo_n_body
    as_echo_n='sh -c $as_echo_n_body as_echo'
  fi
  export as_echo_body
  as_echo='sh -c $as_echo_body as_echo'
fi

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  PATH_SEPARATOR=:
  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
      PATH_SEPARATOR=';'
  }
fi

# Support unset when possible.
if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
  as_unset=unset
else
  as_unset=false
fi


# IFS
# We need space, tab and new line, in precisely that order.  Quoting is
# there to prevent editors from complaining about space-tab.
# (If _AS_PATH_WALK were called with IFS unset, it would disable word
# splitting by setting IFS to empty value.)
IFS=" ""	$as_nl"

# Find who we are.  Look in the path if we contain no directory separator.
case $0 in
  *[\\/]* ) as_myself=$0 ;;
  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
done
IFS=$as_save_IFS

     ;;
esac
# We did not find ourselves, most probably we were run as `sh COMMAND'
# in which case we are not to be found in the path.
if test "x$as_myself" = x; then
  as_myself=$0
fi
if test ! -f "$as_myself"; then
  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
  { (exit 1); exit 1; }
fi

# Work around bugs in pre-3.0 UWIN ksh.
for as_var in ENV MAIL MAILPATH
do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
done
PS1='$ '
PS2='> '
PS4='+ '

# NLS nuisances.
LC_ALL=C
export LC_ALL
LANGUAGE=C
export LANGUAGE

# Required to use basename.
if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi


# Name of the executable.
as_me=`$as_basename -- "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`

# CDPATH.
$as_unset CDPATH


if test "x$CONFIG_SHELL" = x; then
  if (eval ":") 2>/dev/null; then
  as_have_required=yes
else
  as_have_required=no
fi

  if test $as_have_required = yes &&	 (eval ":
(as_func_return () {
  (exit \$1)
}
as_func_success () {
  as_func_return 0
}
as_func_failure () {
  as_func_return 1
}
as_func_ret_success () {
  return 0
}
as_func_ret_failure () {
  return 1
}

exitcode=0
if as_func_success; then
  :
else
  exitcode=1
  echo as_func_success failed.
fi

if as_func_failure; then
  exitcode=1
  echo as_func_failure succeeded.
fi

if as_func_ret_success; then
  :
else
  exitcode=1
  echo as_func_ret_success failed.
fi

if as_func_ret_failure; then
  exitcode=1
  echo as_func_ret_failure succeeded.
fi

if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
  :
else
  exitcode=1
  echo positional parameters were not saved.
fi

test \$exitcode = 0) || { (exit 1); exit 1; }

(
  as_lineno_1=\$LINENO
  as_lineno_2=\$LINENO
  test \"x\$as_lineno_1\" != \"x\$as_lineno_2\" &&
  test \"x\`expr \$as_lineno_1 + 1\`\" = \"x\$as_lineno_2\") || { (exit 1); exit 1; }
") 2> /dev/null; then
  :
else
  as_candidate_shells=
    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  case $as_dir in
	 /*)
	   for as_base in sh bash ksh sh5; do
	     as_candidate_shells="$as_candidate_shells $as_dir/$as_base"
	   done;;
       esac
done
IFS=$as_save_IFS


      for as_shell in $as_candidate_shells $SHELL; do
	 # Try only shells that exist, to save several forks.
	 if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
		{ ("$as_shell") 2> /dev/null <<\_ASEOF
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in
  *posix*) set -o posix ;;
esac

fi


:
_ASEOF
}; then
  CONFIG_SHELL=$as_shell
	       as_have_required=yes
	       if { "$as_shell" 2> /dev/null <<\_ASEOF
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in
  *posix*) set -o posix ;;
esac

fi


:
(as_func_return () {
  (exit $1)
}
as_func_success () {
  as_func_return 0
}
as_func_failure () {
  as_func_return 1
}
as_func_ret_success () {
  return 0
}
as_func_ret_failure () {
  return 1
}

exitcode=0
if as_func_success; then
  :
else
  exitcode=1
  echo as_func_success failed.
fi

if as_func_failure; then
  exitcode=1
  echo as_func_failure succeeded.
fi

if as_func_ret_success; then
  :
else
  exitcode=1
  echo as_func_ret_success failed.
fi

if as_func_ret_failure; then
  exitcode=1
  echo as_func_ret_failure succeeded.
fi

if ( set x; as_func_ret_success y && test x = "$1" ); then
  :
else
  exitcode=1
  echo positional parameters were not saved.
fi

test $exitcode = 0) || { (exit 1); exit 1; }

(
  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2") || { (exit 1); exit 1; }

_ASEOF
}; then
  break
fi

fi

      done

      if test "x$CONFIG_SHELL" != x; then
  for as_var in BASH_ENV ENV
	do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
	done
	export CONFIG_SHELL
	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
fi


    if test $as_have_required = no; then
  echo This script requires a shell more modern than all the
      echo shells that I found on your system.  Please install a
      echo modern shell, or manually run the script under such a
      echo shell if you do have one.
      { (exit 1); exit 1; }
fi


fi

fi



(eval "as_func_return () {
  (exit \$1)
}
as_func_success () {
  as_func_return 0
}
as_func_failure () {
  as_func_return 1
}
as_func_ret_success () {
  return 0
}
as_func_ret_failure () {
  return 1
}

exitcode=0
if as_func_success; then
  :
else
  exitcode=1
  echo as_func_success failed.
fi

if as_func_failure; then
  exitcode=1
  echo as_func_failure succeeded.
fi

if as_func_ret_success; then
  :
else
  exitcode=1
  echo as_func_ret_success failed.
fi

if as_func_ret_failure; then
  exitcode=1
  echo as_func_ret_failure succeeded.
fi

if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
  :
else
  exitcode=1
  echo positional parameters were not saved.
fi

test \$exitcode = 0") || {
  echo No shell found that supports shell functions.
  echo Please tell bug-autoconf@gnu.org about your system,
  echo including any error possibly output before this message.
  echo This can help us improve future autoconf versions.
  echo Configuration will now proceed without shell functions.
}



  as_lineno_1=$LINENO
  as_lineno_2=$LINENO
  test "x$as_lineno_1" != "x$as_lineno_2" &&
  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {

  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
  # uniformly replaced by the line number.  The first 'sed' inserts a
  # line-number line after each line using $LINENO; the second 'sed'
  # does the real work.  The second script uses 'N' to pair each
  # line-number line with the line containing $LINENO, and appends
  # trailing '-' during substitution so that $LINENO is not a special
  # case at line end.
  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
  # scripts with optimization help from Paolo Bonzini.  Blame Lee
  # E. McMahon (1931-1989) for sed's syntax.  :-)
  sed -n '
    p
    /[$]LINENO/=
  ' <$as_myself |
    sed '
      s/[$]LINENO.*/&-/
      t lineno
      b
      :lineno
      N
      :loop
      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
      t loop
      s/-\n.*//
    ' >$as_me.lineno &&
  chmod +x "$as_me.lineno" ||
    { { $as_echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
$as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
   { (exit 1); exit 1; }; }

  # Don't try to exec as it changes $[0], causing all sort of problems
  # (the dirname of $[0] is not the place where we might find the
  # original and so on.  Autoconf is especially sensitive to this).
  . "./$as_me.lineno"
  # Exit status is that of the last command.
  exit
}


if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
  as_dirname=dirname
else
  as_dirname=false
fi

ECHO_C= ECHO_N= ECHO_T=
case `echo -n x` in
-n*)
  case `echo 'x\c'` in
  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
  *)   ECHO_C='\c';;
  esac;;
*)
  ECHO_N='-n';;
esac
if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

rm -f conf$$ conf$$.exe conf$$.file
if test -d conf$$.dir; then
  rm -f conf$$.dir/conf$$.file
else
  rm -f conf$$.dir
  mkdir conf$$.dir 2>/dev/null
fi
if (echo >conf$$.file) 2>/dev/null; then
  if ln -s conf$$.file conf$$ 2>/dev/null; then
    as_ln_s='ln -s'
    # ... but there are two gotchas:
    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
    # In both cases, we have to default to `cp -p'.
    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
      as_ln_s='cp -p'
  elif ln conf$$.file conf$$ 2>/dev/null; then
    as_ln_s=ln
  else
    as_ln_s='cp -p'
  fi
else
  as_ln_s='cp -p'
fi
rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
rmdir conf$$.dir 2>/dev/null

if mkdir -p . 2>/dev/null; then
  as_mkdir_p=:
else
  test -d ./-p && rmdir ./-p
  as_mkdir_p=false
fi

if test -x / >/dev/null 2>&1; then
  as_test_x='test -x'
else
  if ls -dL / >/dev/null 2>&1; then
    as_ls_L_option=L
  else
    as_ls_L_option=
  fi
  as_test_x='
    eval sh -c '\''
      if test -d "$1"; then
	test -d "$1/.";
      else
	case $1 in
	-*)set "./$1";;
	esac;
	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
	???[sx]*):;;*)false;;esac;fi
    '\'' sh
  '
fi
as_executable_p=$as_test_x

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"





SHELL=${CONFIG_SHELL-/bin/sh}

# How were we run?
at_cli_args="$@"


# Not all shells have the 'times' builtin; the subshell is needed to make
# sure we discard the 'times: not found' message from the shell.
at_times_p=false
(times) >/dev/null 2>&1 && at_times_p=:

# CLI Arguments to pass to the debugging scripts.
at_debug_args=
# -e sets to true
at_errexit_p=false
# Shall we be verbose?  ':' means no, empty means yes.
at_verbose=:
at_quiet=

# Shall we keep the debug scripts?  Must be `:' when the suite is
# run by a debug script, so that the script doesn't remove itself.
at_debug_p=false
# Display help message?
at_help_p=false
# Display the version message?
at_version_p=false
# List test groups?
at_list_p=false
# --clean
at_clean=false
# Test groups to run
at_groups=
# Whether a write failure occurred
at_write_fail=0

# The directory we run the suite in.  Default to . if no -C option.
at_dir=`pwd`
# An absolute reference to this testsuite script.
case $as_myself in
  [\\/]* | ?:[\\/]* ) at_myself=$as_myself ;;
  * ) at_myself=$at_dir/$as_myself ;;
esac
# Whether -C is in effect.
at_change_dir=false

# List of the tested programs.
at_tested='locate
updatedb'
# List of the all the test groups.
at_groups_all=' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43'
# As many question marks as there are digits in the last test group number.
# Used to normalize the test group numbers so that `ls' lists them in
# numerical order.
at_format='??'
# Description of all the test groups.
at_help_all="1;config.at:26;config: updatedb.conf;updatedb;
2;config.at:27;config: -f;updatedb;
3;config.at:30;config: -e;updatedb;
4;config.at:52;config: -h;updatedb;
5;config.at:86;config: -n;updatedb;
6;config.at:108;config: -o;updatedb;
7;config.at:118;config: -l;updatedb;
8;config.at:138;config: -U;updatedb;
9;config.at:173;config: -v;updatedb;
10;config.at:200;config: -V;updatedb;
11;config.at:223;config: --debug-pruning;updatedb;
12;config.at:226;config: --prune-bind-mounts;updatedb;
13;config.at:242;config: --prunefs;updatedb;
14;config.at:258;config: --prunenames;updatedb;
15;config.at:288;config: --prunepaths;updatedb;
16;locate.at:17;locate: Basic;locate;
17;locate.at:60;locate: -b;locate;
18;locate.at:89;locate: -c;locate;
19;locate.at:112;locate: -d;locate;
20;locate.at:156;locate: -e;locate;
21;locate.at:192;locate: -h;locate;
22;locate.at:231;locate: -i;locate;
23;locate.at:259;locate: -l, -n;;
24;locate.at:291;locate: -L;locate;
25;locate.at:333;locate: -P;locate;
26;locate.at:381;locate: -S;locate;
27;locate.at:414;locate: -q;locate;
28;locate.at:426;locate: -r;locate;
29;locate.at:463;locate: -V;locate;
30;locate.at:485;locate: -w;locate;
31;locate.at:520;locate: -0;locate;
32;locate.at:537;locate: --regex;locate;
33;locate.at:568;locate: LOCATE_PATH;;
34;locate.at:584;locate: Invalid source database;locate;
35;updatedb.at:17;updatedb: File types;updatedb;
36;updatedb.at:49;updatedb: Output sorting;updatedb;
37;updatedb.at:82;updatedb: Permissions;updatedb;
38;updatedb.at:129;updatedb: Invalid source database;updatedb;
39;updatedb.at:160;updatedb: Change detection;updatedb;
40;updatedb.at:219;updatedb: Concurrent modification;updatedb;
41;updatedb.at:241;updatedb: Very deep hierarchy;updatedb;
42;updatedb.at:268;updatedb: Output creation;;
43;updatedb.at:307;updatedb: Path sorting;;
"

# at_func_validate_ranges [NAME...]
# ---------------------------------
# Validate and normalize the test group number contained in each
# variable NAME.  Leading zeroes are treated as decimal.
at_func_validate_ranges ()
{
  for at_grp
  do
    eval at_value=\$$at_grp
    if test $at_value -lt 1 || test $at_value -gt 43; then
      $as_echo "invalid test group: $at_value" >&2
      exit 1
    fi
    case $at_value in
      0*) # We want to treat leading 0 as decimal, like expr and test, but
	  # at_func_arith treats it as octal if it uses $(( )).
	  # With XSI shells, ${at_value#${at_value%%[1-9]*}} avoids the
	  # expr fork, but it is not worth the effort to determine if the
	  # shell supports XSI when the user can just avoid leading 0.
	  eval $at_grp='`expr $at_value + 0`' ;;
    esac
  done
}

at_prev=
for at_option
do
  # If the previous option needs an argument, assign it.
  if test -n "$at_prev"; then
    at_option=$at_prev=$at_option
    at_prev=
  fi

  case $at_option in
  *=*) at_optarg=`expr "x$at_option" : 'x[^=]*=\(.*\)'` ;;
  *)   at_optarg= ;;
  esac

  # Accept the important Cygnus configure options, so we can diagnose typos.

  case $at_option in
    --help | -h )
	at_help_p=:
	;;

    --list | -l )
	at_list_p=:
	;;

    --version | -V )
	at_version_p=:
	;;

    --clean | -c )
	at_clean=:
	;;

    --debug | -d )
	at_debug_p=:
	;;

    --errexit | -e )
	at_debug_p=:
	at_errexit_p=:
	;;

    --verbose | -v )
	at_verbose=; at_quiet=:
	;;

    --trace | -x )
	at_traceon='set -x'; at_traceoff='set +x'
	;;

    [0-9] | [0-9][0-9] | [0-9][0-9][0-9] | [0-9][0-9][0-9][0-9])
	at_func_validate_ranges at_option
	at_groups="$at_groups$at_option "
	;;

    # Ranges
    [0-9]- | [0-9][0-9]- | [0-9][0-9][0-9]- | [0-9][0-9][0-9][0-9]-)
	at_range_start=`echo $at_option |tr -d X-`
	at_func_validate_ranges at_range_start
	at_range=`$as_echo " $at_groups_all " | \
	  sed -e 's/^.* \('$at_range_start' \)/\1/'`
	at_groups="$at_groups$at_range "
	;;

    -[0-9] | -[0-9][0-9] | -[0-9][0-9][0-9] | -[0-9][0-9][0-9][0-9])
	at_range_end=`echo $at_option |tr -d X-`
	at_func_validate_ranges at_range_end
	at_range=`$as_echo " $at_groups_all " | \
	  sed -e 's/\( '$at_range_end'\) .*$/\1/'`
	at_groups="$at_groups$at_range "
	;;

    [0-9]-[0-9] | [0-9]-[0-9][0-9] | [0-9]-[0-9][0-9][0-9] | \
    [0-9]-[0-9][0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9] | \
    [0-9][0-9]-[0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] )
	at_range_start=`expr $at_option : '\(.*\)-'`
	at_range_end=`expr $at_option : '.*-\(.*\)'`
	if test $at_range_start -gt $at_range_end; then
	  at_tmp=$at_range_end
	  at_range_end=$at_range_start
	  at_range_start=$at_tmp
	fi
	at_func_validate_ranges at_range_start at_range_end
	at_range=`$as_echo " $at_groups_all " | \
	  sed -e 's/^.*\( '$at_range_start' \)/\1/' \
	      -e 's/\( '$at_range_end'\) .*$/\1/'`
	at_groups="$at_groups$at_range "
	;;

    # Directory selection.
    --directory | -C )
	at_prev=--directory
	;;
    --directory=* )
	at_change_dir=:
	at_dir=$at_optarg
	;;

    # Keywords.
    --keywords | -k )
	at_prev=--keywords
	;;
    --keywords=* )
	at_groups_selected=$at_help_all
	at_save_IFS=$IFS
	IFS=,
	set X $at_optarg
	shift
	IFS=$at_save_IFS
	for at_keyword
	do
	  at_invert=
	  case $at_keyword in
	  '!'*)
	    at_invert="-v"
	    at_keyword=`expr "X$at_keyword" : 'X!\(.*\)'`
	    ;;
	  esac
	  # It is on purpose that we match the test group titles too.
	  at_groups_selected=`$as_echo "$at_groups_selected" |
	      grep -i $at_invert "^[1-9][^;]*;.*[; ]$at_keyword[ ;]"`
	done
	# Smash the newlines.
	at_groups_selected=`$as_echo "$at_groups_selected" | sed 's/;.*//' |
	  tr "$as_nl" ' '
	`
	at_groups="$at_groups$at_groups_selected "
	;;

    *=*)
	at_envvar=`expr "x$at_option" : 'x\([^=]*\)='`
	# Reject names that are not valid shell variable names.
	case $at_envvar in
	  '' | [0-9]* | *[!_$as_cr_alnum]* )
	    { { $as_echo "$as_me:$LINENO: error: invalid variable name: $at_envvar" >&5
$as_echo "$as_me: error: invalid variable name: $at_envvar" >&2;}
   { (exit 1); exit 1; }; } ;;
	esac
	at_value=`$as_echo "$at_optarg" | sed "s/'/'\\\\\\\\''/g"`
	# Export now, but save eval for later and for debug scripts.
	export $at_envvar
	at_debug_args="$at_debug_args $at_envvar='$at_value'"
	;;

     *) $as_echo "$as_me: invalid option: $at_option" >&2
	$as_echo "Try \`$0 --help' for more information." >&2
	exit 1
	;;
  esac
done

# Verify our last option didn't require an argument
if test -n "$at_prev"; then
  { { $as_echo "$as_me:$LINENO: error: \`$at_prev' requires an argument." >&5
$as_echo "$as_me: error: \`$at_prev' requires an argument." >&2;}
   { (exit 1); exit 1; }; }
fi


# Selected test groups.
if test -z "$at_groups"; then
  at_groups=$at_groups_all
else
  # Sort the tests, removing duplicates.
  at_groups=`$as_echo "$at_groups" | tr ' ' "$as_nl" | sort -nu`
fi

# Help message.
if $at_help_p; then
  cat <<_ATEOF || at_write_fail=1
Usage: $0 [OPTION]... [VARIABLE=VALUE]... [TESTS]

Run all the tests, or the selected TESTS, given by numeric ranges, and
save a detailed log file.  Upon failure, create debugging scripts.

You should not change environment variables unless explicitly passed
as command line arguments.  Set \`AUTOTEST_PATH' to select the executables
to exercise.  Each relative directory is expanded as build and source
directories relatively to the top level of this distribution.  E.g.,

  $ $0 AUTOTEST_PATH=bin

possibly amounts into

  PATH=/tmp/foo-1.0/bin:/src/foo-1.0/bin:\$PATH
_ATEOF
cat <<_ATEOF || at_write_fail=1

Operation modes:
  -h, --help     print the help message, then exit
  -V, --version  print version number, then exit
  -c, --clean    remove all the files this test suite might create and exit
  -l, --list     describes all the tests, or the selected TESTS
_ATEOF
cat <<_ATEOF || at_write_fail=1

Execution tuning:
  -C, --directory=DIR
                 change to directory DIR before starting
  -k, --keywords=KEYWORDS
                 select the tests matching all the comma-separated KEYWORDS
                 multiple \`-k' accumulate; prefixed \`!' negates a KEYWORD
  -e, --errexit  abort as soon as a test fails; implies --debug
  -v, --verbose  force more detailed output
                 default for debugging scripts
  -d, --debug    inhibit clean up and top-level logging
                 default for debugging scripts
  -x, --trace    enable tests shell tracing
_ATEOF
cat <<_ATEOF || at_write_fail=1

Report bugs to <mitr@redhat.com>.
_ATEOF
  exit $at_write_fail
fi

# List of tests.
if $at_list_p; then
  cat <<_ATEOF || at_write_fail=1
mlocate 0.22.2 test suite test groups:

 NUM: FILE-NAME:LINE     TEST-GROUP-NAME
      KEYWORDS

_ATEOF
  # Passing at_groups is tricky.  We cannot use it to form a literal string
  # or regexp because of the limitation of AIX awk.  And Solaris' awk
  # doesn't grok more than 99 fields in a record, so we have to use `split'.
  # at_groups needs to be space-separated for this script to work.
  case $at_groups in
    *"$as_nl"* )
      at_groups=`$as_echo "$at_groups" | tr "$as_nl" ' '` ;;
  esac
  $as_echo "$at_groups$as_nl$at_help_all" |
    awk 'BEGIN { FS = ";" }
	 NR == 1 {
	   for (n = split($ 0, a, " "); n; n--) selected[a[n]] = 1
	   next
	 }
	 {
	   if (selected[$ 1]) {
	     printf " %3d: %-18s %s\n", $ 1, $ 2, $ 3
	     if ($ 4) printf "      %s\n", $ 4
	   }
	 }' || at_write_fail=1
  exit $at_write_fail
fi
if $at_version_p; then
  $as_echo "$as_me (mlocate 0.22.2)" &&
  cat <<\_ACEOF || at_write_fail=1

Copyright (C) 2006, 2008 Red Hat, Inc. All rights reserved.
This copyrighted material is made available to anyone wishing to use, modify,
copy, or redistribute it subject to the terms and conditions of the GNU
General Public License v.2.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 51
Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

Author: Miloslav Trmac <mitr@redhat.com>

Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
Free Software Foundation, Inc.
This test suite is free software; the Free Software Foundation gives
unlimited permission to copy, distribute and modify it.
_ACEOF
  exit $at_write_fail
fi

# Should we print banners?  at_groups is space-separated for entire test,
# newline-separated if only a subset of the testsuite is run.
case $at_groups in
  *' '*' '* | *"$as_nl"*"$as_nl"* )
      at_print_banners=: ;;
  * ) at_print_banners=false ;;
esac
# Text for banner N, set to empty once printed.

# Take any -C into account.
if $at_change_dir ; then
  if test x- = "x$at_dir" ; then
    at_dir=./-
  fi
  test x != "x$at_dir" && cd "$at_dir" \
    || { { $as_echo "$as_me:$LINENO: error: unable to change directory" >&5
$as_echo "$as_me: error: unable to change directory" >&2;}
   { (exit 1); exit 1; }; }
  at_dir=`pwd`
fi

# Load the config files for any default variable assignments.
for at_file in atconfig atlocal
do
  test -r $at_file || continue
  . ./$at_file || { { $as_echo "$as_me:$LINENO: error: invalid content: $at_file" >&5
$as_echo "$as_me: error: invalid content: $at_file" >&2;}
   { (exit 1); exit 1; }; }
done

# Autoconf <=2.59b set at_top_builddir instead of at_top_build_prefix:
: ${at_top_build_prefix=$at_top_builddir}

# Perform any assignments requested during argument parsing.
eval "$at_debug_args"

# atconfig delivers names relative to the directory the test suite is
# in, but the groups themselves are run in testsuite-dir/group-dir.
if test -n "$at_top_srcdir"; then
  builddir=../..
  for at_dir_var in srcdir top_srcdir top_build_prefix
  do
    at_val=`eval 'as_val=${'at_$at_dir_var'}
		 $as_echo "$as_val"'`
    case $at_val in
      [\\/$]* | ?:[\\/]* ) at_prefix= ;;
      *) at_prefix=../../ ;;
    esac
    eval "$at_dir_var=\$at_prefix\$at_val"
  done
fi

## ------------------- ##
## Directory structure ##
## ------------------- ##

# This is the set of directories and files used by this script
# (non-literals are capitalized):
#
# TESTSUITE         - the testsuite
# TESTSUITE.log     - summarizes the complete testsuite run
# TESTSUITE.dir/    - created during a run, remains after -d or failed test
# + at-groups/      - during a run: status of all groups in run
# | + NNN/          - during a run: meta-data about test group NNN
# | | + check-line  - location (source file and line) of current AT_CHECK
# | | + status      - exit status of current AT_CHECK
# | | + stdout      - stdout of current AT_CHECK
# | | + stder1      - stderr, including trace
# | | + stderr      - stderr, with trace filtered out
# | | + test-source - portion of testsuite that defines group
# | | + times       - timestamps for computing duration
# | | + pass        - created if group passed
# | | + xpass       - created if group xpassed
# | | + fail        - created if group failed
# | | + xfail       - created if group xfailed
# | | + skip        - created if group skipped
# + at-stop         - during a run: end the run if this file exists
# + at-source-lines - during a run: cache of TESTSUITE line numbers for extraction
# + 0..NNN/         - created for each group NNN, remains after -d or failed test
# | + TESTSUITE.log - summarizes the group results
# | + ...           - files created during the group

# The directory the whole suite works in.
# Should be absolute to let the user `cd' at will.
at_suite_dir=$at_dir/$as_me.dir
# The file containing the suite.
at_suite_log=$at_dir/$as_me.log
# The directory containing helper files per test group.
at_helper_dir=$at_suite_dir/at-groups
# Stop file: if it exists, do not start new jobs.
at_stop_file=$at_suite_dir/at-stop

if $at_clean; then
  test -d "$at_suite_dir" &&
    find "$at_suite_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
  rm -f -r "$at_suite_dir" "$at_suite_log"
  exit $?
fi

# Don't take risks: use only absolute directories in PATH.
#
# For stand-alone test suites (ie. atconfig was not found),
# AUTOTEST_PATH is relative to `.'.
#
# For embedded test suites, AUTOTEST_PATH is relative to the top level
# of the package.  Then expand it into build/src parts, since users
# may create executables in both places.
AUTOTEST_PATH=`$as_echo "$AUTOTEST_PATH" | sed "s|:|$PATH_SEPARATOR|g"`
at_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $AUTOTEST_PATH $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -n "$at_path" && at_path=$at_path$PATH_SEPARATOR
case $as_dir in
  [\\/]* | ?:[\\/]* )
    at_path=$at_path$as_dir
    ;;
  * )
    if test -z "$at_top_build_prefix"; then
      # Stand-alone test suite.
      at_path=$at_path$as_dir
    else
      # Embedded test suite.
      at_path=$at_path$at_top_build_prefix$as_dir$PATH_SEPARATOR
      at_path=$at_path$at_top_srcdir/$as_dir
    fi
    ;;
esac
done
IFS=$as_save_IFS


# Now build and simplify PATH.
#
# There might be directories that don't exist, but don't redirect
# builtins' (eg., cd) stderr directly: Ultrix's sh hates that.
at_new_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $at_path
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -d "$as_dir" || continue
case $as_dir in
  [\\/]* | ?:[\\/]* ) ;;
  * ) as_dir=`(cd "$as_dir" && pwd) 2>/dev/null` ;;
esac
case $PATH_SEPARATOR$at_new_path$PATH_SEPARATOR in
  *$PATH_SEPARATOR$as_dir$PATH_SEPARATOR*) ;;
  $PATH_SEPARATOR$PATH_SEPARATOR) at_new_path=$as_dir ;;
  *) at_new_path=$at_new_path$PATH_SEPARATOR$as_dir ;;
esac
done
IFS=$as_save_IFS

PATH=$at_new_path
export PATH

# Setting up the FDs.
# 5 is the log file.  Not to be overwritten if `-d'.
if $at_debug_p; then
  at_suite_log=/dev/null
else
  : >"$at_suite_log"
fi
exec 5>>"$at_suite_log"

# Banners and logs.
cat <<\_ASBOX
## -------------------------- ##
## mlocate 0.22.2 test suite. ##
## -------------------------- ##
_ASBOX
{
  cat <<\_ASBOX
## -------------------------- ##
## mlocate 0.22.2 test suite. ##
## -------------------------- ##
_ASBOX
  echo

  $as_echo "$as_me: command line was:"
  $as_echo "  \$ $0 $at_cli_args"
  echo

  # Try to find a few ChangeLogs in case it might help determining the
  # exact version.  Use the relative dir: if the top dir is a symlink,
  # find will not follow it (and options to follow the links are not
  # portable), which would result in no output here.  Prune directories
  # matching the package tarname, since they tend to be leftovers from
  # `make dist' or `make distcheck' and contain redundant or stale logs.
  if test -n "$at_top_srcdir"; then
    cat <<\_ASBOX
## ----------- ##
## ChangeLogs. ##
## ----------- ##
_ASBOX
    echo
    for at_file in `find "$at_top_srcdir" -name "mlocate-*" -prune -o -name ChangeLog -print`
    do
      $as_echo "$as_me: $at_file:"
      sed 's/^/| /;10q' $at_file
      echo
    done

  fi

  {
cat <<_ASUNAME
## --------- ##
## Platform. ##
## --------- ##

hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
uname -m = `(uname -m) 2>/dev/null || echo unknown`
uname -r = `(uname -r) 2>/dev/null || echo unknown`
uname -s = `(uname -s) 2>/dev/null || echo unknown`
uname -v = `(uname -v) 2>/dev/null || echo unknown`

/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`

/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`

_ASUNAME

as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  $as_echo "PATH: $as_dir"
done
IFS=$as_save_IFS

}
  echo

  # Contents of the config files.
  for at_file in atconfig atlocal
  do
    test -r $at_file || continue
    $as_echo "$as_me: $at_file:"
    sed 's/^/| /' $at_file
    echo
  done
} >&5


## --------------- ##
## Shell functions ##
## --------------- ##

# at_func_banner NUMBER
# ---------------------
# Output banner NUMBER, provided the testsuite is running multiple groups
# and this particular banner has not yet been printed.
at_func_banner ()
{
  $at_print_banners || return 0
  eval at_banner_text=\$at_banner_text_$1
  test "x$at_banner_text" = x && return 0
  eval at_banner_text_$1=
  $as_echo "$as_nl$at_banner_text$as_nl"
} # at_func_banner

# at_func_check_newline COMMAND
# -----------------------------
# Test if COMMAND includes a newline and, if so, print a message and return
# exit code 1
at_func_check_newline ()
{
  case "$1" in
 *'
'*) echo 'Not enabling shell tracing (command contains an embedded newline)'
    return 1 ;;
 *) return 0 ;;
  esac
}

# at_func_filter_trace EXIT-CODE
# ------------------------------
# Split the contents of file "$at_stder1" into the "set -x" trace (on stderr)
# and the other lines (on file "$at_stderr").  Return the exit code EXIT-CODE.
at_func_filter_trace ()
{
  grep '^ *+' "$at_stder1" >&2
  grep -v '^ *+' "$at_stder1" >"$at_stderr"
  return $1
}

# at_func_log_failure FILE-LIST
# -----------------------------
# Copy the files in the list on stdout with a "> " prefix, and exit the shell
# with a failure exit code.
at_func_log_failure ()
{
  for file
    do $as_echo "$file:"; sed 's/^/> /' "$file"; done
  echo 1 > "$at_status_file"
  exit 1
}

# at_func_check_skip EXIT-CODE
# ----------------------------
# Check whether EXIT-CODE is the special exit code 77, and if so exit the shell
# with that same exit code.
at_func_check_skip ()
{
  case $1 in
    77) echo 77 > "$at_status_file"; exit 77;;
  esac
}

# at_func_check_status EXPECTED EXIT-CODE LINE
# --------------------------------------------
# Check whether EXIT-CODE is the expected exit code, and if so do nothing.
# Otherwise, if it is 77 exit the shell with that same exit code; if it is
# anything else print an error message and fail the test.
at_func_check_status ()
{
  case $2 in
    $1 ) ;;
    77) echo 77 > "$at_status_file"; exit 77;;
    *) $as_echo "$3: exit code was $2, expected $1"
      at_failed=:;;
  esac
}

# at_func_diff_devnull FILE
# -------------------------
# Emit a diff between /dev/null and FILE.  Uses "test -s" to avoid useless
# diff invocations.
at_func_diff_devnull ()
{
  test -s "$1" || return 0
  $at_diff "$at_devnull" "$1"
}

# at_func_test NUMBER
# -------------------
# Parse out test NUMBER from the tail of this file.
at_func_test ()
{
  eval at_sed=\$at_sed$1
  sed "$at_sed" "$at_myself" > "$at_test_source"
}

# at_func_create_debugging_script
# -------------------------------
# Create the debugging script $at_group_dir/run which will reproduce the
# current test group.
at_func_create_debugging_script ()
{
  {
    echo "#! /bin/sh" &&
    echo 'test "${ZSH_VERSION+set}" = set && alias -g '\''${1+"$@"}'\''='\''"$@"'\''' &&
    $as_echo "cd '$at_dir'" &&
    $as_echo "exec \${CONFIG_SHELL-$SHELL} \"$at_myself\" -v -d $at_debug_args $at_group \${1+\"\$@\"}" &&
    echo 'exit 1'
  } >"$at_group_dir/run" &&
  chmod +x "$at_group_dir/run"
}

# at_func_arith
# -------------
# Arithmetic evaluation, avoids expr if the shell is sane.  The
# interpretation of leading zeroes is unspecified.
#
# subshell and eval are needed to keep Solaris sh from bailing out:
if ( eval 'test $(( 1 + 1 )) = 2' ) 2>/dev/null; then
  # With "$@", bash does not split positional parameters:
  eval 'at_func_arith ()
  {
    at_func_arith_result=$(( $* ))
  }'
else
  at_func_arith ()
  {
    at_func_arith_result=`expr "$@"`
  }
fi

## ---------------------- ##
## End of shell functions ##
## ---------------------- ##
{
  cat <<\_ASBOX
## ---------------- ##
## Tested programs. ##
## ---------------- ##
_ASBOX
  echo
} >&5

# Report what programs are being tested.
for at_program in : $at_tested
do
  test "$at_program" = : && continue
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  test -f "$as_dir/$at_program" && break
done
IFS=$as_save_IFS

  if test -f "$as_dir/$at_program"; then
    {
      $as_echo "$at_srcdir/testsuite.at:17: $as_dir/$at_program --version"
      "$as_dir/$at_program" --version </dev/null
      echo
    } >&5 2>&1
  else
    { { $as_echo "$as_me:$LINENO: error: cannot find $at_program" >&5
$as_echo "$as_me: error: cannot find $at_program" >&2;}
   { (exit 1); exit 1; }; }
  fi
done

{
  cat <<\_ASBOX
## ------------------ ##
## Running the tests. ##
## ------------------ ##
_ASBOX
} >&5

at_start_date=`date`
at_start_time=`date +%s 2>/dev/null`
$as_echo "$as_me: starting at: $at_start_date" >&5

# Create the master directory if it doesn't already exist.
test -d "$at_suite_dir" ||
  mkdir "$at_suite_dir" ||
  { { $as_echo "$as_me:$LINENO: error: cannot create '$at_suite_dir'" >&5
$as_echo "$as_me: error: cannot create '$at_suite_dir'" >&2;}
   { (exit 1); exit 1; }; }

# Can we diff with `/dev/null'?  DU 5.0 refuses.
if diff /dev/null /dev/null >/dev/null 2>&1; then
  at_devnull=/dev/null
else
  at_devnull=$at_suite_dir/devnull
  >"$at_devnull"
fi

# Use `diff -u' when possible.
if at_diff=`diff -u "$at_devnull" "$at_devnull" 2>&1` && test -z "$at_diff"
then
  at_diff='diff -u'
else
  at_diff=diff
fi

# Get the last needed group.
for at_group in : $at_groups; do :; done

# Extract the start and end lines of each test group at the tail
# of this file
awk '
BEGIN { FS="" }
/^#AT_START_/ {
  start = NR
}
/^#AT_STOP_/ {
  test = substr ($ 0, 10)
  print "at_sed" test "=\"1," start "d;" (NR-1) "q\""
  if (test == "'"$at_group"'") exit
}' "$at_myself" > "$at_suite_dir/at-source-lines" &&
. "$at_suite_dir/at-source-lines" ||
  { { $as_echo "$as_me:$LINENO: error: cannot create test line number cache" >&5
$as_echo "$as_me: error: cannot create test line number cache" >&2;}
   { (exit 1); exit 1; }; }
rm -f "$at_suite_dir/at-source-lines"

# Set up helper dirs.
rm -rf "$at_helper_dir" &&
mkdir "$at_helper_dir" &&
cd "$at_helper_dir" &&
{ test -z "$at_groups" || mkdir $at_groups; } ||
{ { $as_echo "$as_me:$LINENO: error: testsuite directory setup failed" >&5
$as_echo "$as_me: error: testsuite directory setup failed" >&2;}
   { (exit 1); exit 1; }; }

# Functions for running a test group.  We leave the actual
# test group execution outside of a shell function in order
# to avoid hitting zsh 4.x exit status bugs.

# at_func_group_prepare
# ---------------------
# Prepare running a test group
at_func_group_prepare ()
{
  # The directory for additional per-group helper files.
  at_job_dir=$at_helper_dir/$at_group
  # The file containing the location of the last AT_CHECK.
  at_check_line_file=$at_job_dir/check-line
  # The file containing the exit status of the last command.
  at_status_file=$at_job_dir/status
  # The files containing the output of the tested commands.
  at_stdout=$at_job_dir/stdout
  at_stder1=$at_job_dir/stder1
  at_stderr=$at_job_dir/stderr
  # The file containing the code for a test group.
  at_test_source=$at_job_dir/test-source
  # The file containing dates.
  at_times_file=$at_job_dir/times

  # Be sure to come back to the top test directory.
  cd "$at_suite_dir"

  # Clearly separate the test groups when verbose.
  $at_first || $at_verbose echo

  at_group_normalized=$at_group

  eval 'while :; do
    case $at_group_normalized in #(
    '"$at_format"'*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done'


  # Create a fresh directory for the next test group, and enter.
  at_group_dir=$at_suite_dir/$at_group_normalized
  at_group_log=$at_group_dir/$as_me.log
  if test -d "$at_group_dir"; then
    find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
    rm -fr "$at_group_dir" ||
    { $as_echo "$as_me:$LINENO: WARNING: test directory for $at_group_normalized could not be cleaned." >&5
$as_echo "$as_me: WARNING: test directory for $at_group_normalized could not be cleaned." >&2;}
  fi
  # Be tolerant if the above `rm' was not able to remove the directory.
  { as_dir="$at_group_dir"
  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || { { $as_echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
$as_echo "$as_me: error: cannot create directory $as_dir" >&2;}
   { (exit 1); exit 1; }; }; }

  echo 0 > "$at_status_file"

  # In verbose mode, append to the log file *and* show on
  # the standard output; in quiet mode only write to the log.
  if test -z "$at_verbose"; then
    at_tee_pipe='tee -a "$at_group_log"'
  else
    at_tee_pipe='cat >> "$at_group_log"'
  fi
}

# at_func_group_postprocess
# -------------------------
at_func_group_postprocess ()
{
  # Be sure to come back to the suite directory, in particular
  # since below we might `rm' the group directory we are in currently.
  cd "$at_suite_dir"

  if test ! -f "$at_check_line_file"; then
    sed "s/^ */$as_me: WARNING: /" <<_ATEOF
      A failure happened in a test group before any test could be
      run. This means that test suite is improperly designed.  Please
      report this failure to <mitr@redhat.com>.
_ATEOF
    $as_echo "$at_setup_line" >"$at_check_line_file"
  fi
  $at_verbose $as_echo_n "$at_group. $at_setup_line: "
  $as_echo_n "$at_group. $at_setup_line: " >> "$at_group_log"
  case $at_xfail:$at_status in
    yes:0)
	at_msg="UNEXPECTED PASS"
	at_res=xpass
	at_errexit=$at_errexit_p
	;;
    no:0)
	at_msg="ok"
	at_res=pass
	at_errexit=false
	;;
    *:77)
	at_msg='skipped ('`cat "$at_check_line_file"`')'
	at_res=skip
	at_errexit=false
	;;
    yes:*)
	at_msg='expected failure ('`cat "$at_check_line_file"`')'
	at_res=xfail
	at_errexit=false
	;;
    no:*)
	at_msg='FAILED ('`cat "$at_check_line_file"`')'
	at_res=fail
	at_errexit=$at_errexit_p
	;;
  esac
  echo "$at_res" > "$at_job_dir/$at_res"
  # Make sure there is a separator even with long titles.
  $as_echo " $at_msg"
  at_log_msg="$at_group. $at_desc ($at_setup_line): $at_msg"
  case $at_status in
    0|77)
      # $at_times_file is only available if the group succeeded.
      # We're not including the group log, so the success message
      # is written in the global log separately.  But we also
      # write to the group log in case they're using -d.
      if test -f "$at_times_file"; then
	at_log_msg="$at_log_msg     ("`sed 1d "$at_times_file"`')'
	rm -f "$at_times_file"
      fi
      $as_echo "$at_log_msg" >> "$at_group_log"
      $as_echo "$at_log_msg" >&5

      # Cleanup the group directory, unless the user wants the files.
      if $at_debug_p; then
	at_func_create_debugging_script
      else
	if test -d "$at_group_dir"; then
	  find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
	  rm -fr "$at_group_dir"
	fi
	rm -f "$at_test_source"
      fi
      ;;
    *)
      # Upon failure, include the log into the testsuite's global
      # log.  The failure message is written in the group log.  It
      # is later included in the global log.
      $as_echo "$at_log_msg" >> "$at_group_log"

      # Upon failure, keep the group directory for autopsy, and create
      # the debugging script.  With -e, do not start any further tests.
      at_func_create_debugging_script
      if $at_errexit; then
	echo stop > "$at_stop_file"
      fi
      ;;
  esac
}


## ------------ ##
## Driver loop. ##
## ------------ ##

rm -f "$at_stop_file"
at_first=:

for at_group in $at_groups; do
  at_func_group_prepare
  if cd "$at_group_dir" &&
     at_func_test $at_group &&
     . "$at_test_source"; then :; else
    { $as_echo "$as_me:$LINENO: WARNING: unable to parse test group: $at_group" >&5
$as_echo "$as_me: WARNING: unable to parse test group: $at_group" >&2;}
    at_failed=:
  fi
  at_func_group_postprocess
  test -f "$at_stop_file" && break
  at_first=false
done

# Wrap up the test suite with summary statistics.
cd "$at_helper_dir"

# Use ?..???? when the list must remain sorted, the faster * otherwise.
at_pass_list=`for f in */pass; do echo $f; done | sed '/\*/d; s,/pass,,'`
at_skip_list=`for f in */skip; do echo $f; done | sed '/\*/d; s,/skip,,'`
at_xfail_list=`for f in */xfail; do echo $f; done | sed '/\*/d; s,/xfail,,'`
at_xpass_list=`for f in ?/xpass ??/xpass ???/xpass ????/xpass; do
		 echo $f; done | sed '/?/d; s,/xpass,,'`
at_fail_list=`for f in ?/fail ??/fail ???/fail ????/fail; do
		echo $f; done | sed '/?/d; s,/fail,,'`

set X $at_pass_list $at_xpass_list $at_xfail_list $at_fail_list $at_skip_list
shift; at_group_count=$#
set X $at_xpass_list; shift; at_xpass_count=$#; at_xpass_list=$*
set X $at_xfail_list; shift; at_xfail_count=$#
set X $at_fail_list; shift; at_fail_count=$#; at_fail_list=$*
set X $at_skip_list; shift; at_skip_count=$#

at_func_arith $at_group_count - $at_skip_count
at_run_count=$at_func_arith_result
at_func_arith $at_xpass_count + $at_fail_count
at_unexpected_count=$at_func_arith_result
at_func_arith $at_xfail_count + $at_fail_count
at_total_fail_count=$at_func_arith_result

# Back to the top directory.
cd "$at_dir"
rm -rf "$at_helper_dir"

# Compute the duration of the suite.
at_stop_date=`date`
at_stop_time=`date +%s 2>/dev/null`
$as_echo "$as_me: ending at: $at_stop_date" >&5
case $at_start_time,$at_stop_time in
  [0-9]*,[0-9]*)
    at_func_arith $at_stop_time - $at_start_time
    at_duration_s=$at_func_arith_result
    at_func_arith $at_duration_s / 60
    at_duration_m=$at_func_arith_result
    at_func_arith $at_duration_m / 60
    at_duration_h=$at_func_arith_result
    at_func_arith $at_duration_s % 60
    at_duration_s=$at_func_arith_result
    at_func_arith $at_duration_m % 60
    at_duration_m=$at_func_arith_result
    at_duration="${at_duration_h}h ${at_duration_m}m ${at_duration_s}s"
    $as_echo "$as_me: test suite duration: $at_duration" >&5
    ;;
esac

echo
cat <<\_ASBOX
## ------------- ##
## Test results. ##
## ------------- ##
_ASBOX
echo
{
  echo
  cat <<\_ASBOX
## ------------- ##
## Test results. ##
## ------------- ##
_ASBOX
  echo
} >&5

if test $at_run_count = 1; then
  at_result="1 test"
  at_were=was
else
  at_result="$at_run_count tests"
  at_were=were
fi
if $at_errexit_p && test $at_unexpected_count != 0; then
  if test $at_xpass_count = 1; then
    at_result="$at_result $at_were run, one passed"
  else
    at_result="$at_result $at_were run, one failed"
  fi
  at_result="$at_result unexpectedly and inhibited subsequent tests."
else
  # Don't you just love exponential explosion of the number of cases?
  case $at_xpass_count:$at_fail_count:$at_xfail_count in
    # So far, so good.
    0:0:0) at_result="$at_result $at_were successful." ;;
    0:0:*) at_result="$at_result behaved as expected." ;;

    # Some unexpected failures
    0:*:0) at_result="$at_result $at_were run,
$at_fail_count failed unexpectedly." ;;

    # Some failures, both expected and unexpected
    0:*:1) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    0:*:*) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;

    # No unexpected failures, but some xpasses
    *:0:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly." ;;

    # No expected failures, but failures and xpasses
    *:1:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failure)." ;;
    *:*:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failures)." ;;

    # All of them.
    *:*:1) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    *:*:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;
  esac

  if test $at_skip_count = 0 && test $at_run_count -gt 1; then
    at_result="All $at_result"
  fi
fi

# Now put skips in the mix.
case $at_skip_count in
  0) ;;
  1) at_result="$at_result
1 test was skipped." ;;
  *) at_result="$at_result
$at_skip_count tests were skipped." ;;
esac

if test $at_unexpected_count = 0; then
  echo "$at_result"
  echo "$at_result" >&5
else
  echo "ERROR: $at_result" >&2
  echo "ERROR: $at_result" >&5
  {
    echo
    cat <<\_ASBOX
## ------------------------ ##
## Summary of the failures. ##
## ------------------------ ##
_ASBOX

    # Summary of failed and skipped tests.
    if test $at_fail_count != 0; then
      echo "Failed tests:"
      $SHELL "$at_myself" $at_fail_list --list
      echo
    fi
    if test $at_skip_count != 0; then
      echo "Skipped tests:"
      $SHELL "$at_myself" $at_skip_list --list
      echo
    fi
    if test $at_xpass_count != 0; then
      echo "Unexpected passes:"
      $SHELL "$at_myself" $at_xpass_list --list
      echo
    fi
    if test $at_fail_count != 0; then
      cat <<\_ASBOX
## ---------------------- ##
## Detailed failed tests. ##
## ---------------------- ##
_ASBOX
      echo
      for at_group in $at_fail_list
      do
	at_group_normalized=$at_group

  eval 'while :; do
    case $at_group_normalized in #(
    '"$at_format"'*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done'

	cat "$at_suite_dir/$at_group_normalized/$as_me.log"
	echo
      done
      echo
    fi
    if test -n "$at_top_srcdir"; then
      sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## ${at_top_build_prefix}config.log ##
_ASBOX
      sed 's/^/| /' ${at_top_build_prefix}config.log
      echo
    fi
  } >&5

  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $as_me.log was created. ##
_ASBOX

  echo
  $as_echo "Please send \`${at_testdir+${at_testdir}/}$as_me.log' and all information you think might help:

   To: <mitr@redhat.com>
   Subject: [mlocate 0.22.2] $as_me: $at_fail_list${at_fail_list:+ failed${at_xpass_list:+, }}$at_xpass_list${at_xpass_list:+ passed unexpectedly}
"
  if test $at_debug_p = false; then
    echo
    echo 'You may investigate any problem if you feel able to do so, in which'
    echo 'case the test suite provides a good starting point.  Its output may'
    $as_echo "be found below \`${at_testdir+${at_testdir}/}$as_me.dir'."
    echo
  fi
    exit 1
fi

exit 0

## ------------- ##
## Actual tests. ##
## ------------- ##
#AT_START_1
# 1. config.at:26: config: updatedb.conf
at_setup_line='config.at:26'
at_desc="config: updatedb.conf"
$at_quiet $as_echo_n "  1: $at_desc                          "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "1. config.at:26: testing ..."
  $at_traceon


{ $at_traceoff
$as_echo "$at_srcdir/config.at:26: exit 77"
echo config.at:26 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:26"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_1
#AT_START_2
# 2. config.at:27: config: -f
at_setup_line='config.at:27'
at_desc="config: -f"
$at_quiet $as_echo_n "  2: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "2. config.at:27: testing ..."
  $at_traceon


{ $at_traceoff
$as_echo "$at_srcdir/config.at:27: exit 77"
echo config.at:27 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:27"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_2
#AT_START_3
# 3. config.at:30: config: -e
at_setup_line='config.at:30'
at_desc="config: -e"
$at_quiet $as_echo_n "  3: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "3. config.at:30: testing ..."
  $at_traceon



mkdir d
for i in 1 2 3; do
  mkdir d/d$i
  touch d/d$i/f
done

{ $at_traceoff
$as_echo "$at_srcdir/config.at:39: updatedb -U \"\$(pwd)/d\" -o db -l 0 -e \"\$(pwd)/d/d1\" \\
	--add-prunepaths \"\$(pwd)/d/d3 \$(pwd)/this_doesnt_exist\""
echo config.at:39 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 -e "$(pwd)/d/d1" \
	--add-prunepaths "$(pwd)/d/d3 $(pwd)/this_doesnt_exist" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 -e "$(pwd)/d/d1" \
	--add-prunepaths "$(pwd)/d/d3 $(pwd)/this_doesnt_exist" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:39"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/config.at:41: locate -d db / | sed \"s,\$(pwd)/,,\""
echo config.at:41 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/d1
d/d2
d/d3
d/d2/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:41"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_3
#AT_START_4
# 4. config.at:52: config: -h
at_setup_line='config.at:52'
at_desc="config: -h"
$at_quiet $as_echo_n "  4: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "4. config.at:52: testing ..."
  $at_traceon



cat >expout <<'_ATEOF'
Usage: updatedb [OPTION]...
Update a mlocate database.

  -f, --add-prunefs FS           omit also FS
  -n, --add-prunenames NAMES     omit also NAMES
  -e, --add-prunepaths PATHS     omit also PATHS
  -U, --database-root PATH       the subtree to store in database (default "/")
  -h, --help                     print this help
  -o, --output FILE              database to update (default
                                 `PATH')
      --prune-bind-mounts FLAG   omit bind mounts (default "no")
      --prunefs FS               filesystems to omit from database
      --prunenames NAMES         directory names to omit from database
      --prunepaths PATHS         paths to omit from database
  -l, --require-visibility FLAG  check visibility before reporting files
                                 (default "yes")
  -v, --verbose                  print paths of files as they are found
  -V, --version                  print version information

The configuration defaults to values read from
`PATH'.

Report bugs to mitr@redhat.com.
_ATEOF

{ $at_traceoff
$as_echo "$at_srcdir/config.at:80: updatedb -h | sed \"s/\\\`[^']*'/\\\`PATH'/g\""
echo config.at:80 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; updatedb -h | sed "s/\`[^']*'/\`PATH'/g" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -h | sed "s/\`[^']*'/\`PATH'/g" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:80"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/config.at:81: updatedb --help | sed \"s/\\\`[^']*'/\\\`PATH'/g\""
echo config.at:81 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a `...` command substitution)'
   false; }; then
  ( $at_traceon; updatedb --help | sed "s/\`[^']*'/\`PATH'/g" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb --help | sed "s/\`[^']*'/\`PATH'/g" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:81"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_4
#AT_START_5
# 5. config.at:86: config: -n
at_setup_line='config.at:86'
at_desc="config: -n"
$at_quiet $as_echo_n "  5: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "5. config.at:86: testing ..."
  $at_traceon



mkdir d
for i in 1 2 3; do
  mkdir d/e$i
  touch d/e$i/f
done

{ $at_traceoff
$as_echo "$at_srcdir/config.at:95: updatedb -U \"\$(pwd)/d\" -o db -l 0 -n e1 \\
	--add-prunenames \"this_doesnt_exist e3\""
echo config.at:95 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 -n e1 \
	--add-prunenames "this_doesnt_exist e3" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 -n e1 \
	--add-prunenames "this_doesnt_exist e3" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:95"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/config.at:97: locate -d db / | sed \"s,\$(pwd)/,,\""
echo config.at:97 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/e1
d/e2
d/e3
d/e2/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:97"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_5
#AT_START_6
# 6. config.at:108: config: -o
at_setup_line='config.at:108'
at_desc="config: -o"
$at_quiet $as_echo_n "  6: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "6. config.at:108: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/config.at:111: updatedb -U \"\$(pwd)\" -o db --output db"
echo config.at:111 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)" -o db --output db ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)" -o db --output db ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "updatedb: --output specified twice
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:111"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_6
#AT_START_7
# 7. config.at:118: config: -l
at_setup_line='config.at:118'
at_desc="config: -l"
$at_quiet $as_echo_n "  7: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "7. config.at:118: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/config.at:121: updatedb -l 0 --require-visibility 1"
echo config.at:121 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb -l 0 --require-visibility 1 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -l 0 --require-visibility 1 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "updatedb: --require-visibility specified twice
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:121"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/config.at:125: updatedb -l 2"
echo config.at:125 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb -l 2 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -l 2 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "updatedb: invalid value \`2' of --require-visibility
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:125"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/config.at:129: updatedb -l maybe"
echo config.at:129 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb -l maybe ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -l maybe ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "updatedb: invalid value \`maybe' of --require-visibility
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:129"

$at_failed && at_func_log_failure
$at_traceon; }


# Functionality untested

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_7
#AT_START_8
# 8. config.at:138: config: -U
at_setup_line='config.at:138'
at_desc="config: -U"
$at_quiet $as_echo_n "  8: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "8. config.at:138: testing ..."
  $at_traceon



mkdir d
touch d/f
ln -s d link

# Error message is libc-dependent
{ $at_traceoff
$as_echo "$at_srcdir/config.at:146: updatedb -U this_file_doesnt_exist -o db -l 0"
echo config.at:146 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb -U this_file_doesnt_exist -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U this_file_doesnt_exist -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:146"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/config.at:148: updatedb -U / --database-root / -l 0"
echo config.at:148 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb -U / --database-root / -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U / --database-root / -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "updatedb: --database-root specified twice
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:148"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/config.at:152: updatedb -U \"d\" -o db -l 0"
echo config.at:152 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb -U "d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:152"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/config.at:153: locate -d db / | sed \"s,^\$(pwd),PWD,\""
echo config.at:153 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd),PWD," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd),PWD," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "PWD/d
PWD/d/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:153"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/config.at:158: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo config.at:158 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:158"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/config.at:159: locate -d db / | sed \"s,^\$(pwd),PWD,\""
echo config.at:159 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd),PWD," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd),PWD," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "PWD/d
PWD/d/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:159"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/config.at:164: updatedb --database-root \"\$(pwd)/link\" -o db -l 0"
echo config.at:164 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb --database-root "$(pwd)/link" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb --database-root "$(pwd)/link" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:164"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/config.at:165: locate -d db / | sed \"s,^\$(pwd),PWD,\""
echo config.at:165 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd),PWD," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd),PWD," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "PWD/d
PWD/d/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:165"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_8
#AT_START_9
# 9. config.at:173: config: -v
at_setup_line='config.at:173'
at_desc="config: -v"
$at_quiet $as_echo_n "  9: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "9. config.at:173: testing ..."
  $at_traceon



mkdir -p d/d1
touch d/f1 d/d1/f

# Let updatedb consider $(pwd)/d stable
sleep 2

{ $at_traceoff
$as_echo "$at_srcdir/config.at:182: updatedb -U \"\$(pwd)/d\" -o db -l 0 -v | sed \"s,\$(pwd)/,,\" | sort"
echo config.at:182 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 -v | sed "s,$(pwd)/,," | sort ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 -v | sed "s,$(pwd)/,," | sort ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/d1
d/d1/f
d/f1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:182"

$at_failed && at_func_log_failure
$at_traceon; }


# Merging doesn't change output
{ $at_traceoff
$as_echo "$at_srcdir/config.at:189: updatedb -U \"\$(pwd)/d\" -o db -l 0 --verbose | sed \"s,\$(pwd)/,,\" \\
	| sort"
echo config.at:189 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 --verbose | sed "s,$(pwd)/,," \
	| sort ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 --verbose | sed "s,$(pwd)/,," \
	| sort ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/d1
d/d1/f
d/f1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:189"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_9
#AT_START_10
# 10. config.at:200: config: -V
at_setup_line='config.at:200'
at_desc="config: -V"
$at_quiet $as_echo_n " 10: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "10. config.at:200: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/config.at:203: updatedb -V | sed '1s/) .*/) /'"
echo config.at:203 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb -V | sed '1s/) .*/) /' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -V | sed '1s/) .*/) /' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "updatedb (mlocate) 
Copyright (C) 2007 Red Hat, Inc. All rights reserved.
This software is distributed under the GPL v.2.

This program is provided with NO WARRANTY, to the extent permitted by law.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:203"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/config.at:211: updatedb --version | sed '1s/) .*/) /'"
echo config.at:211 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb --version | sed '1s/) .*/) /' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb --version | sed '1s/) .*/) /' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "updatedb (mlocate) 
Copyright (C) 2007 Red Hat, Inc. All rights reserved.
This software is distributed under the GPL v.2.

This program is provided with NO WARRANTY, to the extent permitted by law.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:211"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_10
#AT_START_11
# 11. config.at:223: config: --debug-pruning
at_setup_line='config.at:223'
at_desc="config: --debug-pruning"
$at_quiet $as_echo_n " 11: $at_desc                        "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "11. config.at:223: testing ..."
  $at_traceon


{ $at_traceoff
$as_echo "$at_srcdir/config.at:223: exit 77"
echo config.at:223 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; exit 77 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; exit 77 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:223"

$at_failed && at_func_log_failure
$at_traceon; }

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_11
#AT_START_12
# 12. config.at:226: config: --prune-bind-mounts
at_setup_line='config.at:226'
at_desc="config: --prune-bind-mounts"
$at_quiet $as_echo_n " 12: $at_desc                    "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "12. config.at:226: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/config.at:229: updatedb --prune-bind-mounts no --prune-bind-mounts yes"
echo config.at:229 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb --prune-bind-mounts no --prune-bind-mounts yes ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb --prune-bind-mounts no --prune-bind-mounts yes ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "updatedb: --prune-bind-mounts would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:229"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/config.at:233: updatedb --prune-bind-mounts maybe"
echo config.at:233 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb --prune-bind-mounts maybe ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb --prune-bind-mounts maybe ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "updatedb: invalid value \`maybe' of --prune-bind-mounts
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:233"

$at_failed && at_func_log_failure
$at_traceon; }


# Functionality untested

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_12
#AT_START_13
# 13. config.at:242: config: --prunefs
at_setup_line='config.at:242'
at_desc="config: --prunefs"
$at_quiet $as_echo_n " 13: $at_desc                              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "13. config.at:242: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/config.at:245: updatedb --prunefs foo --prunefs bar"
echo config.at:245 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb --prunefs foo --prunefs bar ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb --prunefs foo --prunefs bar ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "updatedb: --prunefs would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:245"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/config.at:249: updatedb -f foo --prunefs bar"
echo config.at:249 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb -f foo --prunefs bar ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -f foo --prunefs bar ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "updatedb: --prunefs would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:249"

$at_failed && at_func_log_failure
$at_traceon; }


# Functionality untested

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_13
#AT_START_14
# 14. config.at:258: config: --prunenames
at_setup_line='config.at:258'
at_desc="config: --prunenames"
$at_quiet $as_echo_n " 14: $at_desc                           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "14. config.at:258: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/config.at:261: updatedb --prunenames foo --prunenames bar"
echo config.at:261 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb --prunenames foo --prunenames bar ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb --prunenames foo --prunenames bar ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "updatedb: --prunenames would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:261"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/config.at:265: updatedb -n foo --prunenames bar"
echo config.at:265 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb -n foo --prunenames bar ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -n foo --prunenames bar ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "updatedb: --prunenames would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:265"

$at_failed && at_func_log_failure
$at_traceon; }


mkdir d
for i in 1 2 3; do
  mkdir d/e$i
  touch d/e$i/f
done

{ $at_traceoff
$as_echo "$at_srcdir/config.at:275: updatedb -U \"\$(pwd)/d\" -o db -l 0 \\
	--prunenames \"e3 this_doesnt_exist e1\""
echo config.at:275 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 \
	--prunenames "e3 this_doesnt_exist e1" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 \
	--prunenames "e3 this_doesnt_exist e1" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:275"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/config.at:277: locate -d db / | sed \"s,\$(pwd)/,,\""
echo config.at:277 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/e1
d/e2
d/e3
d/e2/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:277"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_14
#AT_START_15
# 15. config.at:288: config: --prunepaths
at_setup_line='config.at:288'
at_desc="config: --prunepaths"
$at_quiet $as_echo_n " 15: $at_desc                           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "15. config.at:288: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/config.at:291: updatedb --prunepaths foo --prunepaths bar"
echo config.at:291 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb --prunepaths foo --prunepaths bar ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb --prunepaths foo --prunepaths bar ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "updatedb: --prunepaths would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:291"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/config.at:295: updatedb -e foo --prunepaths bar"
echo config.at:295 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; updatedb -e foo --prunepaths bar ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -e foo --prunepaths bar ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "updatedb: --prunepaths would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/config.at:295"

$at_failed && at_func_log_failure
$at_traceon; }


mkdir d
for i in 1 2 3; do
  mkdir d/d$i
  touch d/d$i/f
done

{ $at_traceoff
$as_echo "$at_srcdir/config.at:305: updatedb -U \"\$(pwd)/d\" -o db -l 0 \\
	--prunepaths \"\$(pwd)/d/d3 \$(pwd)/d/d1 \$(pwd)/this_doesnt_exist\""
echo config.at:305 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 \
	--prunepaths "$(pwd)/d/d3 $(pwd)/d/d1 $(pwd)/this_doesnt_exist" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 \
	--prunepaths "$(pwd)/d/d3 $(pwd)/d/d1 $(pwd)/this_doesnt_exist" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:305"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/config.at:307: locate -d db / | sed \"s,\$(pwd)/,,\""
echo config.at:307 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/d1
d/d2
d/d3
d/d2/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/config.at:307"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_15
#AT_START_16
# 16. locate.at:17: locate: Basic
at_setup_line='locate.at:17'
at_desc="locate: Basic"
$at_quiet $as_echo_n " 16: $at_desc                                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "16. locate.at:17: testing ..."
  $at_traceon



mkdir d
touch d/foo d/bar d/baz

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:23: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo locate.at:23 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:23"

$at_failed && at_func_log_failure
$at_traceon; }


rm d/bar

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:27: locate -d db d/f | sed \"s,\$(pwd)/,,\""
echo locate.at:27 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db d/f | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db d/f | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:27"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:31: locate -d db '*d/b*' d/baz | sed \"s,\$(pwd)/,,\""
echo locate.at:31 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db '*d/b*' d/baz | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db '*d/b*' d/baz | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/bar
d/baz
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:31"

$at_failed && at_func_log_failure
$at_traceon; }


# Ignored options
{ $at_traceoff
$as_echo "$at_srcdir/locate.at:37: locate -d db -m d/f | sed \"s,\$(pwd)/,,\""
echo locate.at:37 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -m d/f | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -m d/f | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:37"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:40: locate -d db --mmap d/f | sed \"s,\$(pwd)/,,\""
echo locate.at:40 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db --mmap d/f | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --mmap d/f | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:40"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:43: locate -d db -s d/f | sed \"s,\$(pwd)/,,\""
echo locate.at:43 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -s d/f | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -s d/f | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:43"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:46: locate -d db --stdio d/f | sed \"s,\$(pwd)/,,\""
echo locate.at:46 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db --stdio d/f | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --stdio d/f | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:46"

$at_failed && at_func_log_failure
$at_traceon; }


# Error message is libc-dependent
{ $at_traceoff
$as_echo "$at_srcdir/locate.at:51: locate --this-option-doesnt-exist"
echo locate.at:51 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate --this-option-doesnt-exist ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate --this-option-doesnt-exist ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo stderr:; cat "$at_stderr"
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:51"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:53: locate -d db"
echo locate.at:53 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: no pattern to search for specified
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:53"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_16
#AT_START_17
# 17. locate.at:60: locate: -b
at_setup_line='locate.at:60'
at_desc="locate: -b"
$at_quiet $as_echo_n " 17: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "17. locate.at:60: testing ..."
  $at_traceon



mkdir -p d/my_basename
touch d/my_basename/f

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:66: locate -b --basename"
echo locate.at:66 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -b --basename ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -b --basename ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: --basename would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:66"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:70: locate -w -b"
echo locate.at:70 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -w -b ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -w -b ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: --basename would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:70"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:74: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo locate.at:74 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:74"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:76: locate -d db -b my_basename | sed \"s,\$(pwd)/,,\""
echo locate.at:76 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -b my_basename | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -b my_basename | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/my_basename
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:76"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:80: locate -d db --basename my_basename | sed \"s,\$(pwd)/,,\""
echo locate.at:80 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db --basename my_basename | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --basename my_basename | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/my_basename
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:80"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:84: locate -d db -b /my_basename"
echo locate.at:84 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db -b /my_basename ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -b /my_basename ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:84"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_17
#AT_START_18
# 18. locate.at:89: locate: -c
at_setup_line='locate.at:89'
at_desc="locate: -c"
$at_quiet $as_echo_n " 18: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "18. locate.at:89: testing ..."
  $at_traceon



mkdir d
touch d/foo d/bar

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:95: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo locate.at:95 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:95"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:97: locate -d db -c '*'"
echo locate.at:97 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db -c '*' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -c '*' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "3
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:97"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:101: locate -d db --count foo"
echo locate.at:101 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db --count foo ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --count foo ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "1
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:101"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:105: locate -d db -c this_doesnt_exist"
echo locate.at:105 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db -c this_doesnt_exist ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -c this_doesnt_exist ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "0
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:105"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_18
#AT_START_19
# 19. locate.at:112: locate: -d
at_setup_line='locate.at:112'
at_desc="locate: -d"
$at_quiet $as_echo_n " 19: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "19. locate.at:112: testing ..."
  $at_traceon



mkdir d1 d2
touch d1/f d2/f

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:118: updatedb -U \"\$(pwd)/d1\" -o db1 -l 0"
echo locate.at:118 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d1" -o db1 -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d1" -o db1 -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:118"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:119: updatedb -U \"\$(pwd)/d2\" -o db2 -l 0"
echo locate.at:119 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d2" -o db2 -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d2" -o db2 -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:119"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:121: locate -d db1 --database db2 '*' | sed \"s,\$(pwd)/,,\""
echo locate.at:121 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db1 --database db2 '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db1 --database db2 '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d1
d1/f
d2
d2/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:121"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:128: locate -d db2:db1 '*' | sed \"s,\$(pwd)/,,\""
echo locate.at:128 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db2:db1 '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db2:db1 '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d2
d2/f
d1
d1/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:128"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:135: locate -d - '*' < db1 | sed \"s,\$(pwd)/,,\""
echo locate.at:135 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d - '*' < db1 | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d - '*' < db1 | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d1
d1/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:135"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:140: locate -d - '*' < db1 | sed \"s,\$(pwd)/,,\""
echo locate.at:140 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d - '*' < db1 | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d - '*' < db1 | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d1
d1/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:140"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:145: locate -d -:- '*' < db1 > out"
echo locate.at:145 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d -:- '*' < db1 > out ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d -:- '*' < db1 > out ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: can not read two databases from standard input
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:145"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:148: sed \"s,\$(pwd)/,,\" < out"
echo locate.at:148 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; sed "s,$(pwd)/,," < out ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed "s,$(pwd)/,," < out ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d1
d1/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:148"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_19
#AT_START_20
# 20. locate.at:156: locate: -e
at_setup_line='locate.at:156'
at_desc="locate: -e"
$at_quiet $as_echo_n " 20: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "20. locate.at:156: testing ..."
  $at_traceon



mkdir d
touch d/f d/g
ln -s f d/symlink
ln -s this_doesnt_exist d/danglink

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:164: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo locate.at:164 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:164"

$at_failed && at_func_log_failure
$at_traceon; }


rm d/g

# Existence is not checked by default
{ $at_traceoff
$as_echo "$at_srcdir/locate.at:169: locate -d db '*' | sed \"s,\$(pwd)/,,\""
echo locate.at:169 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/danglink
d/f
d/g
d/symlink
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:169"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:177: locate -d db -e '*' | sed \"s,\$(pwd)/,,\""
echo locate.at:177 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -e '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -e '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/f
d/symlink
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:177"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:183: locate -d db --existing '*' | sed \"s,\$(pwd)/,,\""
echo locate.at:183 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db --existing '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --existing '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/f
d/symlink
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:183"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_20
#AT_START_21
# 21. locate.at:192: locate: -h
at_setup_line='locate.at:192'
at_desc="locate: -h"
$at_quiet $as_echo_n " 21: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "21. locate.at:192: testing ..."
  $at_traceon



cat >expout <<'_ATEOF'
Usage: locate [OPTION]... [PATTERN]...
Search for entries in a mlocate database.

  -b, --basename         match only the base name of path names
  -c, --count            only print number of found entries
  -d, --database DBPATH  use DBPATH instead of default database (which is
                         PATH)
  -e, --existing         only print entries for currently existing files
  -L, --follow           follow trailing symbolic links when checking file
                         existence (default)
  -h, --help             print this help
  -i, --ignore-case      ignore case distinctions when matching patterns
  -l, --limit, -n LIMIT  limit output (or counting) to LIMIT entries
  -m, --mmap             ignored, for backward compatibility
  -P, --nofollow, -H     don't follow trailing symbolic links when checking file
                         existence
  -0, --null             separate entries with NUL on output
  -S, --statistics       don't search for entries, print statistics about each
                         used database
  -q, --quiet            report no error messages about reading databases
  -r, --regexp REGEXP    search for basic regexp REGEXP instead of patterns
      --regex            patterns are extended regexps
  -s, --stdio            ignored, for backward compatibility
  -V, --version          print version information
  -w, --wholename        match whole path name (default)

Report bugs to mitr@redhat.com.
_ATEOF


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:225: locate -h | sed 's,^\\([ 	]*\\)/.*)\$,\\1PATH),'"
echo locate.at:225 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "locate -h | sed 's,^\\([ 	]*\\)/.*)$,\\1PATH),'"; then
  ( $at_traceon; locate -h | sed 's,^\([ 	]*\)/.*)$,\1PATH),' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -h | sed 's,^\([ 	]*\)/.*)$,\1PATH),' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:225"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:226: locate --help | sed 's,^\\([ 	]*\\)/.*)\$,\\1PATH),'"
echo locate.at:226 >"$at_check_line_file"

if test -n "$at_traceon" \
  && at_func_check_newline "locate --help | sed 's,^\\([ 	]*\\)/.*)$,\\1PATH),'"; then
  ( $at_traceon; locate --help | sed 's,^\([ 	]*\)/.*)$,\1PATH),' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate --help | sed 's,^\([ 	]*\)/.*)$,\1PATH),' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:226"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_21
#AT_START_22
# 22. locate.at:231: locate: -i
at_setup_line='locate.at:231'
at_desc="locate: -i"
$at_quiet $as_echo_n " 22: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "22. locate.at:231: testing ..."
  $at_traceon



mkdir d
touch d/foo d/fOo d/Foo

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:237: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo locate.at:237 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:237"

$at_failed && at_func_log_failure
$at_traceon; }


# Search is case-sensitive by default
{ $at_traceoff
$as_echo "$at_srcdir/locate.at:240: locate -d db foo | sed \"s,\$(pwd)/,,\""
echo locate.at:240 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db foo | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db foo | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:240"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:244: locate -d db -i 'foo' | sed \"s,\$(pwd)/,,\""
echo locate.at:244 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -i 'foo' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -i 'foo' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/Foo
d/fOo
d/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:244"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:250: locate -d db --ignore-case '*oo' | sed \"s,\$(pwd)/,,\""
echo locate.at:250 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db --ignore-case '*oo' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --ignore-case '*oo' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/Foo
d/fOo
d/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:250"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_22
#AT_START_23
# 23. locate.at:259: locate: -l, -n
at_setup_line='locate.at:259'
at_desc="locate: -l, -n"
$at_quiet $as_echo_n " 23: $at_desc                                 "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "23. locate.at:259: testing ..."
  $at_traceon


mkdir d
touch d/f d/g

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:264: locate -l 0 --limit 1"
echo locate.at:264 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -l 0 --limit 1 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -l 0 --limit 1 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: --limit specified twice
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:264"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:267: locate --limit 0 -n 1"
echo locate.at:267 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate --limit 0 -n 1 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate --limit 0 -n 1 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: --limit specified twice
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:267"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:270: locate --limit invalid_integer"
echo locate.at:270 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate --limit invalid_integer ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate --limit invalid_integer ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: invalid value \`invalid_integer' of --limit
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:270"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:274: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo locate.at:274 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:274"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:276: locate -d db -l 1 '*' | sed \"s,\$(pwd)/,,\""
echo locate.at:276 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -l 1 '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -l 1 '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:276"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:280: locate -d db --limit 99999 '*' | sed \"s,\$(pwd)/,,\""
echo locate.at:280 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db --limit 99999 '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --limit 99999 '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/f
d/g
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:280"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:286: locate -d db -n 0 this_doesnt_exist"
echo locate.at:286 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db -n 0 this_doesnt_exist ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -n 0 this_doesnt_exist ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:286"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_23
#AT_START_24
# 24. locate.at:291: locate: -L
at_setup_line='locate.at:291'
at_desc="locate: -L"
$at_quiet $as_echo_n " 24: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "24. locate.at:291: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/locate.at:294: locate -L -L"
echo locate.at:294 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -L -L ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -L -L ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: --follow would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:294"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:298: locate -H --follow"
echo locate.at:298 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -H --follow ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -H --follow ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: --follow would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:298"

$at_failed && at_func_log_failure
$at_traceon; }


mkdir d
touch d/f d/g
ln -s f d/symlink
ln -s this_doesnt_exist d/danglink

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:307: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo locate.at:307 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:307"

$at_failed && at_func_log_failure
$at_traceon; }


rm d/g

# -L is the default
{ $at_traceoff
$as_echo "$at_srcdir/locate.at:312: locate -d db -e '*' | sed \"s,\$(pwd)/,,\""
echo locate.at:312 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -e '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -e '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/f
d/symlink
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:312"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:318: locate -d db -eL '*' | sed \"s,\$(pwd)/,,\""
echo locate.at:318 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -eL '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -eL '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/f
d/symlink
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:318"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:324: locate -d db -e --follow '*' | sed \"s,\$(pwd)/,,\""
echo locate.at:324 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -e --follow '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -e --follow '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/f
d/symlink
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:324"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_24
#AT_START_25
# 25. locate.at:333: locate: -P
at_setup_line='locate.at:333'
at_desc="locate: -P"
$at_quiet $as_echo_n " 25: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "25. locate.at:333: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/locate.at:336: locate -P --nofollow"
echo locate.at:336 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -P --nofollow ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -P --nofollow ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: --nofollow would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:336"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:340: locate -L -P"
echo locate.at:340 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -L -P ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -L -P ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: --nofollow would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:340"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:344: locate -L -H"
echo locate.at:344 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -L -H ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -L -H ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: --nofollow would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:344"

$at_failed && at_func_log_failure
$at_traceon; }


mkdir d
touch d/f d/g
ln -s f d/symlink
ln -s this_doesnt_exist d/danglink

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:353: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo locate.at:353 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:353"

$at_failed && at_func_log_failure
$at_traceon; }


rm d/g

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:357: locate -d db -eH '*' | sed \"s,\$(pwd)/,,\""
echo locate.at:357 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -eH '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -eH '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/danglink
d/f
d/symlink
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:357"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:364: locate -d db -e -P '*' | sed \"s,\$(pwd)/,,\""
echo locate.at:364 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -e -P '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -e -P '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/danglink
d/f
d/symlink
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:364"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:371: locate -d db -e --nofollow '*' | sed \"s,\$(pwd)/,,\""
echo locate.at:371 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -e --nofollow '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -e --nofollow '*' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/danglink
d/f
d/symlink
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:371"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_25
#AT_START_26
# 26. locate.at:381: locate: -S
at_setup_line='locate.at:381'
at_desc="locate: -S"
$at_quiet $as_echo_n " 26: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "26. locate.at:381: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/locate.at:384: locate -S foo"
echo locate.at:384 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -S foo ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -S foo ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: non-option arguments are not allowed with --statistics
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:384"

$at_failed && at_func_log_failure
$at_traceon; }


mkdir d
touch d/f

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:391: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo locate.at:391 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:391"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:393: locate -d db -S | sed 's/[0123456789]* bytes\\{0,1\\}/BYTES bytes/'"
echo locate.at:393 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db -S | sed 's/[0123456789]* bytes\{0,1\}/BYTES bytes/' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -S | sed 's/[0123456789]* bytes\{0,1\}/BYTES bytes/' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Database db:
	1 directory
	2 files
	BYTES bytes in file names
	BYTES bytes used to store database
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:393"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:402: locate -d - --statistics < db \\
	| sed 's/[0123456789]* bytes\\{0,1\\}/BYTES bytes/'"
echo locate.at:402 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains an embedded newline)'
   false; }; then
  ( $at_traceon; locate -d - --statistics < db \
	| sed 's/[0123456789]* bytes\{0,1\}/BYTES bytes/' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d - --statistics < db \
	| sed 's/[0123456789]* bytes\{0,1\}/BYTES bytes/' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "Database -:
	1 directory
	2 files
	BYTES bytes in file names
	BYTES bytes used to store database
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:402"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_26
#AT_START_27
# 27. locate.at:414: locate: -q
at_setup_line='locate.at:414'
at_desc="locate: -q"
$at_quiet $as_echo_n " 27: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "27. locate.at:414: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/locate.at:417: locate -d this_doesnt_exist -q '*'"
echo locate.at:417 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d this_doesnt_exist -q '*' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d this_doesnt_exist -q '*' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:417"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:418: locate -d this_doesnt_exist --quiet '*'"
echo locate.at:418 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d this_doesnt_exist --quiet '*' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d this_doesnt_exist --quiet '*' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:418"

$at_failed && at_func_log_failure
$at_traceon; }


printf '\000mlocate\000\000\000\000\000\377xx-' > db
{ $at_traceoff
$as_echo "$at_srcdir/locate.at:421: locate -d db -q '*'"
echo locate.at:421 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db -q '*' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -q '*' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:421"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_27
#AT_START_28
# 28. locate.at:426: locate: -r
at_setup_line='locate.at:426'
at_desc="locate: -r"
$at_quiet $as_echo_n " 28: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "28. locate.at:426: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/locate.at:429: locate -d db -r '.*' '*'"
echo locate.at:429 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db -r '.*' '*' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -r '.*' '*' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: non-option arguments are not allowed with --regexp
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:429"

$at_failed && at_func_log_failure
$at_traceon; }


mkdir d
touch d/foo d/Foo d/bar

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:436: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo locate.at:436 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:436"

$at_failed && at_func_log_failure
$at_traceon; }


# Default is not to use regexps
{ $at_traceoff
$as_echo "$at_srcdir/locate.at:439: locate -d db '.*f.o'"
echo locate.at:439 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db '.*f.o' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db '.*f.o' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:439"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:441: locate -d db -r '.*foo' | sed \"s,\$(pwd)/,,\""
echo locate.at:441 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -r '.*foo' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -r '.*foo' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:441"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:445: locate -d db --regexp '.*foo' -r '.*d/bar' | sed \"s,\$(pwd)/,,\""
echo locate.at:445 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db --regexp '.*foo' -r '.*d/bar' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --regexp '.*foo' -r '.*d/bar' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/bar
d/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:445"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:450: locate -d db --regexp '.*foo' -i | sed \"s,\$(pwd)/,,\""
echo locate.at:450 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db --regexp '.*foo' -i | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --regexp '.*foo' -i | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/Foo
d/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:450"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:455: locate -d db --regexp '\\(' 2> err"
echo locate.at:455 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db --regexp '\(' 2> err ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --regexp '\(' 2> err ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:455"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:456: sed \"s/': .*/': /\" < err"
echo locate.at:456 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; sed "s/': .*/': /" < err ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed "s/': .*/': /" < err ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "locate: invalid regexp \`\\(': 
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:456"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_28
#AT_START_29
# 29. locate.at:463: locate: -V
at_setup_line='locate.at:463'
at_desc="locate: -V"
$at_quiet $as_echo_n " 29: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "29. locate.at:463: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/locate.at:466: locate -V | sed '1s/ .*/ /'"
echo locate.at:466 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -V | sed '1s/ .*/ /' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -V | sed '1s/ .*/ /' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "mlocate 
Copyright (C) 2007 Red Hat, Inc. All rights reserved.
This software is distributed under the GPL v.2.

This program is provided with NO WARRANTY, to the extent permitted by law.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:466"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:474: locate --version | sed '1s/ .*/ /'"
echo locate.at:474 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate --version | sed '1s/ .*/ /' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate --version | sed '1s/ .*/ /' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "mlocate 
Copyright (C) 2007 Red Hat, Inc. All rights reserved.
This software is distributed under the GPL v.2.

This program is provided with NO WARRANTY, to the extent permitted by law.
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:474"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_29
#AT_START_30
# 30. locate.at:485: locate: -w
at_setup_line='locate.at:485'
at_desc="locate: -w"
$at_quiet $as_echo_n " 30: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "30. locate.at:485: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/locate.at:488: locate -w --wholename"
echo locate.at:488 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -w --wholename ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -w --wholename ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: --wholename would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:488"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:492: locate -b -w"
echo locate.at:492 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -b -w ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -b -w ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: --wholename would override earlier command-line argument
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:492"

$at_failed && at_func_log_failure
$at_traceon; }


mkdir d
touch d/f

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:499: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo locate.at:499 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:499"

$at_failed && at_func_log_failure
$at_traceon; }


# -w is the default
{ $at_traceoff
$as_echo "$at_srcdir/locate.at:502: locate -d db '/d' | sed \"s,\$(pwd)/,,\""
echo locate.at:502 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db '/d' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db '/d' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:502"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:507: locate -d db -w '/d' | sed \"s,\$(pwd)/,,\""
echo locate.at:507 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -w '/d' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -w '/d' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:507"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:512: locate -d db --wholename '/d' | sed \"s,\$(pwd)/,,\""
echo locate.at:512 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db --wholename '/d' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --wholename '/d' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:512"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_30
#AT_START_31
# 31. locate.at:520: locate: -0
at_setup_line='locate.at:520'
at_desc="locate: -0"
$at_quiet $as_echo_n " 31: $at_desc                                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "31. locate.at:520: testing ..."
  $at_traceon



mkdir d
touch d/bar d/baz

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:526: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo locate.at:526 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:526"

$at_failed && at_func_log_failure
$at_traceon; }


printf 'd/bar\000d/baz\000' > expout

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:530: locate -d db -0 d/b | sed \"s,\$(pwd)/,,g\""
echo locate.at:530 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db -0 d/b | sed "s,$(pwd)/,,g" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db -0 d/b | sed "s,$(pwd)/,,g" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:530"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:532: locate -d db --null d/b | sed \"s,\$(pwd)/,,g\""
echo locate.at:532 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db --null d/b | sed "s,$(pwd)/,,g" ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --null d/b | sed "s,$(pwd)/,,g" ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:532"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_31
#AT_START_32
# 32. locate.at:537: locate: --regex
at_setup_line='locate.at:537'
at_desc="locate: --regex"
$at_quiet $as_echo_n " 32: $at_desc                                "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "32. locate.at:537: testing ..."
  $at_traceon



mkdir d
touch d/foo d/Foo d/fOo d/bar d/baz

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:543: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo locate.at:543 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:543"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:545: locate -d db --regex '.*d/baz' '.*d/bar' | sed \"s,\$(pwd)/,,\""
echo locate.at:545 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db --regex '.*d/baz' '.*d/bar' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --regex '.*d/baz' '.*d/bar' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/bar
d/baz
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:545"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:550: locate -d db --regex '.*d/foo' | sed \"s,\$(pwd)/,,\""
echo locate.at:550 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db --regex '.*d/foo' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --regex '.*d/foo' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:550"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:554: locate -d db --regex -i '.*d/foo' | sed \"s,\$(pwd)/,,\""
echo locate.at:554 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db --regex -i '.*d/foo' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --regex -i '.*d/foo' | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d/Foo
d/fOo
d/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:554"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:560: locate -d db --regex '(' 2> err"
echo locate.at:560 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db --regex '(' 2> err ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db --regex '(' 2> err ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:560"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:561: sed \"s/': .*/': /\" < err"
echo locate.at:561 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; sed "s/': .*/': /" < err ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed "s/': .*/': /" < err ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "locate: invalid regexp \`(': 
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:561"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_32
#AT_START_33
# 33. locate.at:568: locate: LOCATE_PATH
at_setup_line='locate.at:568'
at_desc="locate: LOCATE_PATH"
$at_quiet $as_echo_n " 33: $at_desc                            "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "33. locate.at:568: testing ..."
  $at_traceon


mkdir d1 d2
touch d1/foo d2/foo

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:573: updatedb -U \"\$(pwd)/d1\" -o db1 -l 0"
echo locate.at:573 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d1" -o db1 -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d1" -o db1 -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:573"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:574: updatedb -U \"\$(pwd)/d2\" -o db2 -l 0"
echo locate.at:574 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d2" -o db2 -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d2" -o db2 -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:574"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/locate.at:576: LOCATE_PATH=db1 locate -d db2 /foo | sed \"s,\$(pwd)/,,\""
echo locate.at:576 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; LOCATE_PATH=db1 locate -d db2 /foo | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; LOCATE_PATH=db1 locate -d db2 /foo | sed "s,$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d2/foo
d1/foo
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:576"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_33
#AT_START_34
# 34. locate.at:584: locate: Invalid source database
at_setup_line='locate.at:584'
at_desc="locate: Invalid source database"
$at_quiet $as_echo_n " 34: $at_desc                "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "34. locate.at:584: testing ..."
  $at_traceon



{ $at_traceoff
$as_echo "$at_srcdir/locate.at:587: locate -d db '*' 2>err"
echo locate.at:587 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db '*' 2>err ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db '*' 2>err ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:587"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/locate.at:588: sed \"s/': .*/': /\" < err"
echo locate.at:588 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; sed "s/': .*/': /" < err ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed "s/': .*/': /" < err ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "locate: can not stat () \`db': 
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/locate.at:588"

$at_failed && at_func_log_failure
$at_traceon; }


> db
{ $at_traceoff
$as_echo "$at_srcdir/locate.at:593: locate -d db '*'"
echo locate.at:593 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db '*' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db '*' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: unexpected EOF reading \`db'
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:593"

$at_failed && at_func_log_failure
$at_traceon; }


echo '0123456789abcdef-' > db
{ $at_traceoff
$as_echo "$at_srcdir/locate.at:598: locate -d db '*'"
echo locate.at:598 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db '*' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db '*' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: \`db' does not seem to be a mlocate database
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:598"

$at_failed && at_func_log_failure
$at_traceon; }


printf '\000mlocate\000\000\000\000\377\000xx-' > db
{ $at_traceoff
$as_echo "$at_srcdir/locate.at:603: locate -d db '*'"
echo locate.at:603 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db '*' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db '*' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: \`db' has unknown version 255
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:603"

$at_failed && at_func_log_failure
$at_traceon; }


printf '\000mlocate\000\000\000\000\000\377xx-' > db
{ $at_traceoff
$as_echo "$at_srcdir/locate.at:608: locate -d db '*'"
echo locate.at:608 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db '*' ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db '*' ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
echo >>"$at_stderr"; $as_echo "locate: \`db' has unknown visibility flag 255
" | \
  $at_diff - "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/locate.at:608"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_34
#AT_START_35
# 35. updatedb.at:17: updatedb: File types
at_setup_line='updatedb.at:17'
at_desc="updatedb: File types"
$at_quiet $as_echo_n " 35: $at_desc                           "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "35. updatedb.at:17: testing ..."
  $at_traceon



mkdir d
touch d/file
mkdir d/dir
touch d/dir/subfile
mkfifo d/fifo
ln -s file d/symlink
ln -s nonexistent d/danglink
touch d/hardlink1
ln d/hardlink1 d/hardlink2
echo | dd > d/largefile bs=1024 seek=5000000

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:31: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:31 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:31"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:33: locate -d db / | sed \"s,^\$(pwd)/,,\""
echo updatedb.at:33 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/danglink
d/dir
d/fifo
d/file
d/hardlink1
d/hardlink2
d/largefile
d/symlink
d/dir/subfile
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:33"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_35
#AT_START_36
# 36. updatedb.at:49: updatedb: Output sorting
at_setup_line='updatedb.at:49'
at_desc="updatedb: Output sorting"
$at_quiet $as_echo_n " 36: $at_desc                       "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "36. updatedb.at:49: testing ..."
  $at_traceon



# '.', '/' left out

  allchars='! " # $ % & '\'' ( ) * + , - 0 9 : ; < = > ?'	     # emacs: "
  allchars="$allchars"' @ A Z [ \ ] ^ _ ` a z { | } ~'


mkdir d
echo 'd' > subdirs
> subdir_files
set -f
for dir in $allchars; do
  mkdir "d/$dir"
  echo "d/$dir" >> subdirs
  for file in $allchars; do
    touch "d/$dir/$file"
    echo "d/$dir/$file" >> subdir_files
  done
done
set +f

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:72: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:72 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:72"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:74: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:74 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:74"

$at_failed && at_func_log_failure
$at_traceon; }


cat subdirs subdir_files > expout
{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:77: locate -d db / | sed \"s,^\$(pwd)/,,\""
echo updatedb.at:77 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:77"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_36
#AT_START_37
# 37. updatedb.at:82: updatedb: Permissions
at_setup_line='updatedb.at:82'
at_desc="updatedb: Permissions"
$at_quiet $as_echo_n " 37: $at_desc                          "
at_xfail=no
      test "x`id -u`" = x0 && at_xfail=yes
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "37. updatedb.at:82: testing ..."
  $at_traceon





perms='000 100 200 300 400 500 600 700'

mkdir d
for perm in $perms; do
  mkdir -p "d/d$perm" "d/d$perm/d"
  touch "d/f$perm" "d/d$perm/d/f"
  chmod "$perm" "d/f$perm" "d/d$perm"
done

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:96: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:96 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:96"

$at_failed && at_func_log_failure
$at_traceon; }


{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:98: locate -d db / | sed \"s,^\$(pwd)/,,\""
echo updatedb.at:98 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/d000
d/d100
d/d200
d/d300
d/d400
d/d500
d/d600
d/d700
d/f000
d/f100
d/f200
d/f300
d/f400
d/f500
d/f600
d/f700
d/d500/d
d/d500/d/f
d/d700/d
d/d700/d/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:98"

$at_failed && at_func_log_failure
$at_traceon; }


# Allow cleaning up
chmod -R u+rwx d
rm -rf d

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_37
#AT_START_38
# 38. updatedb.at:129: updatedb: Invalid source database
at_setup_line='updatedb.at:129'
at_desc="updatedb: Invalid source database"
$at_quiet $as_echo_n " 38: $at_desc              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "38. updatedb.at:129: testing ..."
  $at_traceon



mkdir d
touch d/f

cat >expout <<'_ATEOF'
d
d/f
_ATEOF



> db
{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:142: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:142 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:142"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:143: locate -d db / | sed \"s,^\$(pwd)/,,\""
echo updatedb.at:143 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:143"

$at_failed && at_func_log_failure
$at_traceon; }


echo '0123456789abcdef-' > db
{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:146: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:146 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:146"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:147: locate -d db / | sed \"s,^\$(pwd)/,,\""
echo updatedb.at:147 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:147"

$at_failed && at_func_log_failure
$at_traceon; }


printf '\000mlocate\000\000\000\000\377\000xx-' > db
{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:150: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:150 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:150"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:151: locate -d db / | sed \"s,^\$(pwd)/,,\""
echo updatedb.at:151 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:151"

$at_failed && at_func_log_failure
$at_traceon; }


printf '\000mlocate\000\000\000\000\000\377xx-' > db
{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:154: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:154 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:154"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:155: locate -d db / | sed \"s,^\$(pwd)/,,\""
echo updatedb.at:155 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
$at_diff expout "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:155"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_38
#AT_START_39
# 39. updatedb.at:160: updatedb: Change detection
at_setup_line='updatedb.at:160'
at_desc="updatedb: Change detection"
$at_quiet $as_echo_n " 39: $at_desc                     "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "39. updatedb.at:160: testing ..."
  $at_traceon



mkdir -p d/d0
touch d/f0 d/d0/f

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:166: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:166 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:166"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:167: locate -d db / | sed \"s,^\$(pwd)/,,\""
echo updatedb.at:167 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/d0
d/f0
d/d0/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:167"

$at_failed && at_func_log_failure
$at_traceon; }


mv d/d0 d/d1

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:176: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:176 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:176"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:177: locate -d db / | sed \"s,^\$(pwd)/,,\""
echo updatedb.at:177 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/d1
d/f0
d/d1/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:177"

$at_failed && at_func_log_failure
$at_traceon; }


mv d/f0 d/f1

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:186: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:186 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:186"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:187: locate -d db / | sed \"s,^\$(pwd)/,,\""
echo updatedb.at:187 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/d1
d/f1
d/d1/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:187"

$at_failed && at_func_log_failure
$at_traceon; }


touch d/f2
mkdir d/d2

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:197: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:197 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:197"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:198: locate -d db / | sed \"s,^\$(pwd)/,,\""
echo updatedb.at:198 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/d1
d/d2
d/f1
d/f2
d/d1/f
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:198"

$at_failed && at_func_log_failure
$at_traceon; }


rm -r d/d1 d/f1

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:209: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:209 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:209"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:210: locate -d db / | sed \"s,^\$(pwd)/,,\""
echo updatedb.at:210 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/d2
d/f2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:210"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_39
#AT_START_40
# 40. updatedb.at:219: updatedb: Concurrent modification
at_setup_line='updatedb.at:219'
at_desc="updatedb: Concurrent modification"
$at_quiet $as_echo_n " 40: $at_desc              "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "40. updatedb.at:219: testing ..."
  $at_traceon



mkdir d
touch d/f1

(cd d; while :; do mv f1 f2; mv f2 f1; done) &
bgpid=$!

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:228: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:228 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:228"

$at_failed && at_func_log_failure
$at_traceon; }


kill -KILL $bgpid
sleep 1 # Wait for the background process to terminate

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:233: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:233 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:233"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:234: locate -d db / -c"
echo updatedb.at:234 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db / -c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / -c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "2
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:234"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_40
#AT_START_41
# 41. updatedb.at:241: updatedb: Very deep hierarchy
at_setup_line='updatedb.at:241'
at_desc="updatedb: Very deep hierarchy"
$at_quiet $as_echo_n " 41: $at_desc                  "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "41. updatedb.at:241: testing ..."
  $at_traceon



# updatedb has two limits:
# - path name length of OBSTACK_SIZE_MAX, currently limiting the depth to
#   roughly 29000
# - resource limit on file descriptors, one per directory; site-dependent,
#   let's assume roughly 1024 are available
mkdir d
(
  cd d
  for depth in $(seq 1 950); do
    # $PSW and $OLDPWD eventually become larger than ARG_MAX
    PWD= OLDPWD= mkdir "depth$depth-abcdefghijklmnopqrstuvwxyz"
    # bash's cd complains if the path is too long
    cd "depth$depth-abcdefghijklmnopqrstuvwxyz" 2>/dev/null
  done
)

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:260: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:260 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:260"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:261: locate -d db / -c"
echo updatedb.at:261 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; locate -d db / -c ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / -c ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "951
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:261"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_41
#AT_START_42
# 42. updatedb.at:268: updatedb: Output creation
at_setup_line='updatedb.at:268'
at_desc="updatedb: Output creation"
$at_quiet $as_echo_n " 42: $at_desc                      "
at_xfail=no
      test "x`id -u`" = x0 && at_xfail=yes
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "42. updatedb.at:268: testing ..."
  $at_traceon




mkdir d out
chmod 500 out

echo "updatedb: can not open a temporary file for \`$(pwd)/out/db'" > experr
{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:276: updatedb -U \"\$(pwd)/d\" -o out/db -l 0"
echo updatedb.at:276 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o out/db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o out/db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
$at_diff experr "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/updatedb.at:276"

$at_failed && at_func_log_failure
$at_traceon; }


mkdir d2
chmod 600 d2

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:281: updatedb -U \"\$(pwd)/d2\" -o db -l 0 2> error"
echo updatedb.at:281 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d2" -o db -l 0 2> error ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d2" -o db -l 0 2> error ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 1 $at_status "$at_srcdir/updatedb.at:281"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:282: sed \"s,\$(pwd)/,DIR/,; s/': .*\$/': /\" < error"
echo updatedb.at:282 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; sed "s,$(pwd)/,DIR/,; s/': .*$/': /" < error ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; sed "s,$(pwd)/,DIR/,; s/': .*$/': /" < error ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "updatedb: can not change directory to \`DIR/d2': 
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:282"

$at_failed && at_func_log_failure
$at_traceon; }


(
  umask 000
  { $at_traceoff
$as_echo "$at_srcdir/updatedb.at:288: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:288 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:288"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/updatedb.at:289: ls -l db | cut -c 1-10"
echo updatedb.at:289 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls -l db | cut -c 1-10 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls -l db | cut -c 1-10 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "-rw-rw-rw-
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:289"

$at_failed && at_func_log_failure
$at_traceon; }

)

(
  umask 777
  { $at_traceoff
$as_echo "$at_srcdir/updatedb.at:296: updatedb -U \"\$(pwd)/d\" -o db -l 0"
echo updatedb.at:296 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb -U "$(pwd)/d" -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:296"

$at_failed && at_func_log_failure
$at_traceon; }

  { $at_traceoff
$as_echo "$at_srcdir/updatedb.at:297: ls -l db | cut -c 1-10"
echo updatedb.at:297 >"$at_check_line_file"

if test -n "$at_traceon"; then
  ( $at_traceon; ls -l db | cut -c 1-10 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; ls -l db | cut -c 1-10 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "----------
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:297"

$at_failed && at_func_log_failure
$at_traceon; }

)

chmod 700 out d2

  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_42
#AT_START_43
# 43. updatedb.at:307: updatedb: Path sorting
at_setup_line='updatedb.at:307'
at_desc="updatedb: Path sorting"
$at_quiet $as_echo_n " 43: $at_desc                         "
at_xfail=no
echo "#                             -*- compilation -*-" >> "$at_group_log"
(
  $as_echo "43. updatedb.at:307: testing ..."
  $at_traceon


mkdir -p d/a/z d/a.b d/a.c
touch d/a/z/x d/a.b/x d/a.c/x
# The correct sort order of conf_prunepaths is d/a/z d/a.b.  An incorrect sort
# order, e.g. d/a.b d/a/z, would prune only d/a/z.

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:314: updatedb --prunepaths \"\$(pwd)/d/a.b \$(pwd)/d/a/z\" -U \"\$(pwd)/d\" \\
	 -o db -l 0"
echo updatedb.at:314 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; updatedb --prunepaths "$(pwd)/d/a.b $(pwd)/d/a/z" -U "$(pwd)/d" \
	 -o db -l 0 ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; updatedb --prunepaths "$(pwd)/d/a.b $(pwd)/d/a/z" -U "$(pwd)/d" \
	 -o db -l 0 ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
at_func_diff_devnull "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:314"

$at_failed && at_func_log_failure
$at_traceon; }

{ $at_traceoff
$as_echo "$at_srcdir/updatedb.at:316: locate -d db / | sed \"s,^\$(pwd)/,,\""
echo updatedb.at:316 >"$at_check_line_file"

if { echo 'Not enabling shell tracing (command contains a $(...) command substitution)'
   false; }; then
  ( $at_traceon; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stder1"
  at_func_filter_trace $?
else
  ( :; locate -d db / | sed "s,^$(pwd)/,," ) >"$at_stdout" 2>"$at_stderr"
fi
at_status=$?
at_failed=false
at_func_diff_devnull "$at_stderr" || at_failed=:
echo >>"$at_stdout"; $as_echo "d
d/a
d/a.b
d/a.c
d/a/z
d/a.c/x
" | \
  $at_diff - "$at_stdout" || at_failed=:
at_func_check_status 0 $at_status "$at_srcdir/updatedb.at:316"

$at_failed && at_func_log_failure
$at_traceon; }


  $at_traceoff
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 | eval $at_tee_pipe
at_status=`cat "$at_status_file"`
#AT_STOP_43
